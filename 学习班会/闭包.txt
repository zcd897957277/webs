闭包是一种现象，而不是一种实例，只是一种解决方案
函数对象可以通过作用域链相互关联起来
函数体内部的变量都可以保存在函数作用域内
函数变量可以隐藏作用域链之内看起来好像是函数将变量包裹了起来
常用于共享函数内的私有变量
闭包 （closure）
一：变量的作用域
要理解闭包，首先必须理解JavaScript特殊的变量作用域，变量的作用域分为两种（1）全局变量 （2）局部变量
javaScript语言的特殊之处在于函数内部可以读取全局变量；
JS代码 :
var n=999;
function f1(){
  console.log(n);
}
f1();   //999  函数内部可以访问全局变量；
在函数外部无法访问函数内部的变量；
JS 代码
function f1(){
  var n=999;
}
alert(n); //error  在console中会出现（n is not defined）在这里如果在声明变量的时候前边没有加 var ，那么就是相当于声明一个全局变量；
JS 代码
function f2(){
   n=999;
}
alert(n);
二：如何从函数外部读取函数内部的变量：在函数的内部在定义一个函数！！
JS 代码
function f1(){
   var n=999;
   function f2(){
      console.log(n);
   }
}
f1当中包含一个子函数f2，所以f2可以使用f1当中所有的变量的，但是f1不能读取f2所有的变量， 这就是javaScript语言所特有的链式调用；
子对象会一级级的寻找父对象所有的变量，但是父对象不能使用子对象变量；
function f1(){
   function f2(){
    var i=500;
    	alert(i); 
    }
return f2;
}
var result=f1();
result();   //既然f2可以读取f1所有的变量，那么把f2作为f1的返回值，f1在外部就可以读取f2的局部变量；
三 闭包的概念：闭包就是能够读取其他函数内部变量的函数； 在JAVAScript语言中，只有函数内部的子函数才能读取父函数变量，因此可以把闭包简单理解成”定义在一个函数内部的函数“ 本质上 -->闭包就是将函数内部和函数外部链接起来的一座桥梁；
四：闭包的用途：一个可以读取内部的变量，一个是让这些值使用保存在内存当中；
function f1(){
   var n=999;
   nAdd=function(){n=n+1};
   function f2(){
    alert(n);
   }
return f2;
}
var result=f1();
result();
nAdd();


function f1(){
   var n=999;
   nAdd=function(){
     n+=1;  
  }
   function f2(){
      alert(n);  
   }
   return f2;
}
  result=f1();
  result();
  nAdd();
  result();      
输出：999 undenfined 1000

function f1(){
  var n=999;
  nAdd=function(){
     var n=100;
     alert(n);
  }
  function f2(){
    alert(n);
  }
  alert(n);
  return nAdd;
}
var result=f1();
result();
输出：999 100

五 使用闭包应该注意的特点：
由于闭包会使得函数中的变量都被保存在内存当中，内存消耗很大，所以不能滥用闭包，否则造成网页的性能问题，在ie当中可能会导致内存泄露，解决的方法是，在推出函数之前，将不适用的局部变量全部删除；
闭包会在父函数外部，改变父函数内部变量的值，所以如果你把父函数当做对象使用，把闭包当做他的方法，把内部变量当做他的私有属性，这是一定要小心，不要随便改父函数内部变量的值；
var name="The Window";
var object={
name:"my Object",
getNameFun:function(){
return function(){
return this.name;
}
}
}
alert(object.getNameFun()());
输出：The Window


JavaScript当中关于闭包的例子
function outerFun(){
var a=0;
function innerFun(){
a++;
alert(a);
}
}
innerFun();  //此处调用 console当中打出error : innerFun的作用域是在outerFun的内部，所以在outerFun的外部调用是错误的；
修改之后的写法为:
function outerFun(){
var a=0;
function innerFun(){
a++;
alert(a);
}
return innerFun;
}
var result=outerFun();
result();//1
result();//2
result();//3
var result1=outerFun();  //相当于从新调用了一次函数；
result1();//1
result1();//2
result1();//3

什么是闭包？
当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的闭包，如果内部函数引用了位于外部函数的变量，当外部函数被调用完毕后，这些变量在内存不会被释放，因为闭包需要他们；
function outerFun(){
  var a=0;
  alert(a);
}
  var a=4;
  outerFun();
  alert(a); // 0  4        

function outerFun(){
  a=0;
  alert(a);
}
var a=4;
outerFun();
alert(a);//0 0

作用域链就是描述一种路径的术语，沿着该路径可以确定变量的值，当执行a=0时，因为没有使用var 关键字，因此赋值操作会沿着作用域链到var a=4;
并且可以改变他的值；
function a(){
var i=0；
function b(){
alert(++i);
}
return b;
}
var c=a();
c(); //1     //其中存在的引用关系，当执行完 var c=a的时候,变量c实际上是指向了函数a的内部函数b; 当函数a的内部函数b被函数a之外的一个变量引用的时候，就创建了一个闭包；

闭包的微观事件，如果需要加深对闭包的理解，那么就要了解另外的几个概念： 函数的执行环境，活动对象，作用域，作用域链
当执行函数a的时候，a会进入一个相应的执行环境，在创建执行环境的过程当中，会为a添加一个属性，就是a的作用域，然后执行环境会创建一个活动对象，活动对象也是一个有属性的对象，但他不具备原型而且不能通过javaScript的代码进行直接的访问，创建完活动对象之后，把活动对象添加到a的作用域链的最顶端，此时a的作用域链包含了两个对象，a的活动对象和window对象。当在函数b当中访问一个变量的时候，搜索顺序为先查找自身的活动对象，如果存在则返回，如果不存在，则继续查找父元素的活动对象。依次查找，直到找到为止；