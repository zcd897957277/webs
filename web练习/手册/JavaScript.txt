*************************************************
                                第一天
1. JavaScript概述
   1. 脚本语言：只有在运行的时候才会被编译或解释的语言
      解释型：执行时才检查语法错误
      JS解释器/引擎：JS脚本的运行环境
	1. 独立安装的JS解释器（Node.JS）
	2. 嵌入在浏览器内核中的JS解释器
2. JavaScript基础语法
   1. 使用JS
	1. 浏览器内核
	   作用：页面的渲染
	   组成：
	     1. 内容排版引擎：解释HTML/CSS
             2. 脚本解释引擎：解析JS
	   1. IE	
	      内核： Trident
	      内容排本引擎：-
	      脚本解释引擎：Chakra
	   2. Firefox
	      内核：Cecko
	      内容排本引擎：-
	      脚本解释引擎：Monkey
	   3. Safari
	      内核：Webkit
	      内容排本引擎：WebCore
	      脚本解释引擎：Nitro
	   4. Chrome
	      内核：Webkit
	      内容排本引擎：WebCore
	      脚本解释引擎：V8(最快最好)	
	   5. Opera
	      2013年之前
	      内核：Presto
	      内容排本引擎：-
	      脚本解释引擎：Carakan
	      2013年之后
	      内核：Webkit
	      内容排本引擎：WebCore
	      脚本解释引擎：V8(最快最好)
	2. 搭建JS运行环境
	   1. 独立安装的JS解释器
		Node.JS
		console.log("415444554454");
	      作用：向控制台中打印输出一句话
	   2. 嵌入在浏览器中的JS解释器
	      1. 直接在 浏览器 的控制台Console输入脚本并执行
	      2. 将JS脚本嵌入在HTML页面中执行
		1. 通过html元素事件完成脚本执行
		   事件： onclick
		   <button onclick="document.write('<h1>hello world!</h1>');"></button>
	        2. 将脚本 嵌入在 Script 标记中
		   <script>
		     JS脚本代码。。。。
		   </script>
		3. 允许将脚本写在外部文件中（*.js）,在页面中进行引入即可
		   1. 创建一个.js文件
		   2. 文件中直接编写JS脚本代码
 		   3. 通过<script src="js文件路径"></script>引入
			1. 必须是双标记
			2. script元素中，不能出现任何JS代码
			3. 注意顺序
	   3. 练习
		1. 创建1.html,创建一个<script>元素，在页面上以红色打印出自己的姓名
		2. 1.html中，添加一个按钮。为按钮增加 单击事件，在控制台上打印出自己的姓名
		3. 使用外部脚本文件。将步骤1再执行一遍
   2. JS的调试
      JS碰到错误后，只会终止当前块的执行，并不会影响后续块以及html的解析

      练习：
	1. 创建2.html,编写一个<script>,其中使用三行语句尝试在页面打印出“hello1”,“hello2”,“hello3”,其中第二行语句特意编写错误，观察输出结果
	2. 创建3.html,编写一个<script>,其中使用三行语句尝试在控制台打印出“world1”,“world2”,“world3”，其中第二行语句特意编写错误，观察输出结果
   3. 语法规范
      1. 代码组成
	 语句： 会被JS引擎所解释执行的代码
	 由： 表达式、关键字、运算符组成，严格区分大小写
		console.log();y
		Console.log();x
	 以 ; 进行结尾

      2. 注释
	 1. 单行注释
	    // 单行注释
	 2. 多行注释
	    /* */
	 
3. 变量（重点）
      问题：假设 我的 工资为5000元，每年工资涨幅为10%，计算10年后我的工资是多少？
      
      内存：临时保存程序运行时要用到的数据
      变量： 内存中的一段存储空间，用来保存数据而用的。
      变量名： 内存空间的别名
      变量的值： 存储在内存空间中的数据

      1. 声明变量
	 作用： 到内存中申请一段空间，并且指定一个别名。
	 var  变量名;

 	 使用 “=” 为变量赋值
	 变量名=值;  将值赋予给变量名
	
	 简写：
	 var 变量名=值;  声明并赋值
	 
	 注意：
	   1. 声明变量的时候，尽量不要省略var关键字， 如果 省略了var,有可能会造成“全局污染”的结果
	   2. 声明变量如果为赋值，则有一个默认值，为undefined

	 一次性声明多个变量：
	 var 变量名1，变量名2，...，变量名n;
	 var 变量名1=值1，变量名2=值2，...，变量名n=值n;
      2. 变量名的命名规范
	 1. 不允许使用JS的关键字和保留关键字
		关键字：var,if,else,while,for...
		保留关键字：class,int,float...
	 2. 规范
	    1. 可以包含字母、数字、下滑线以及$
	    2. 不能以数字开头
	        var name1;可以
		var 1name;不可以
	    3. 尽量见名只意
		var a;不可取
		var stuName;可以
	    4. 可以采用“匈牙利命名法”，“驼峰命名法”，“下划线命名法”
		“匈牙利命名法”：涉及获取页面表单控件时使用 txt...
		“驼峰命名法”:单一单词 采用全小写 var age;
			合成词：第一个单词全小写，其余每一个单词首字母大写 var userAge;
		“下划线命名法”:var _salary;
      3. 变量的使用
	 1. 只声明未赋值，值为undefined
	 2. 变量如果未经声明直接使用
		console.log(test);报错  语法错误！！！
	 3. 对变量进行存/取操作
	    存：赋值操作
	    取：取值操作									    1. 存 - SET 操作
		变量出现在赋值符号（=）的左边
		var userAge;
		userAge=18;
	    2. 取 - GET 操作
		只要不出现在赋值符号的左边，都是取值
		var userAge=18; //声明并赋值
		console.log(userAge);	
		var newAge=userAge;//前者是赋值，后者取值
	       注意：赋值符号的左边只能是变量
		var userAge=18;
		18=18;//不成立
		18=25;//不成立	
	 4. 练习
	    1. 创建html,在<script>元素中声明三个变量，用来保存快餐店推出的一款套餐内容
		1.1 用一个变量保存一种汉堡的名称
		1.2 用一个变量保存配餐的名称
		1.3 用一个变量保存饮料的名称
	    2. 追加程序，输出套餐名称及其内容
		套餐名称：
		香辣鸡腿堡
		配餐：
		香辣鸡腿
		饮料：
		可乐
	    3. 尝试为一个未声明过的变量赋值，再输出
	    4. 输出一个未声明过的变量，观察结果						4. 运算符
    1. 赋值运算符
	= 

	var userName="张三";
    2. 算数运算符
	+，-，*，/，%、
	%：取余，俗称 模
	5%2 ... 1
	2%5 ... 2
	使用场合：
	  1. 判断奇偶性
	  2. 判断数字是否为几的倍数
	  3. 获取某数字的最后几位
        优先级：先*/%再+-  可以通过小括号（）提升优先级
	算数表达式：由算数运算符，连同操作数所组成的表达式。
 
5. 常量
	console.log("黑历史了");
     1. 什么是常量
	一旦声明好，就不允许再程序运行过程中修改的数据，就是常量。
     2. 声明常量
	const 常量名=值；
	注意：
	    声明时，必须赋初始值
	    常量名称，采用全大写形式	                      
6. 数据类型  
     1. 什么是数据类型
	保存的数据的类型
	
	作用： 不同类型的数据所开开辟的空间大小不一样
     2. 数据类型分类
	1. 原始类型（基本类型）
	   1. number 类型
	      数字类型

	      可以表示32位的整数，也可以表示64位的浮点数
	      8位=1字节（byte）

	      整数占4个字节，小数占8个字节
	      十进制：123456
	      八进制：010
	      十六进制：0x123ef
	   2. string 类型
	      字符串 类型

	      使用：需要用 “”或‘’将值括起来

	      特殊字符需要进行转义，
	      转义字符： \n：换行   \t:一个制表符  \r:回车  \":一个“  \':一个‘  \\:\
		console.log("hello'\n'world");
	   3. boolean 布尔类型
		只记录“真”或“假”
		true: 真
		false:假

		在+-*/运算中
		true:当做1运算
		false：当0做运算
	   4. undefined
	      语义： 不存在该数据
	      产生的原因：
		1. 声明的对象未赋值
		2. 访问的对象的属性不存在
	练习：
	1. 创建变量分别保存学生的年龄，入学成绩，身高，体重，并且输出到控制台上
	2. 创建变量分别保存学生的性别，姓名，电话，邮箱，并且输出到控制台上
	3. 创建变量保存 今天是否下雨？ 天是否冷？

2. 引用类型 

*************************************************
                                第二天    

6. 数据类型  
     1. 什么是数据类型
	保存的数据的类型
	
	作用： 不同类型的数据所开开辟的空间大小不一样
     2. 数据类型分类
	1. 原始类型（基本类型）
	   1. number 类型
	      数字类型

	      可以表示32位的整数，也可以表示64位的浮点数
	      8位=1字节（byte）

	      整数占4个字节，小数占8个字节
	      十进制：123456
	      八进制：010
	      十六进制：0x123ef
	   2. string 类型
	      字符串 类型

	      使用：需要用 “”或‘’将值括起来

	      特殊字符需要进行转义，
	      转义字符： \n：换行   \t:一个制表符:一些空格  \r:回车  \":一个“  \':一个‘  \\:\
		console.log("hello'\n'world");
	   3. boolean 布尔类型
		只记录“真”或“假”
		true: 真
		false:假

		在+-*/运算中
		true:当做1运算
		false：当0做运算
	   4. undefined
	      语义： 不存在该数据
	      产生的原因：
		1. 声明的对象未赋值
		2. 访问的对象的属性不存在
	   5. null
	      语义：空（配合对象引用数据类型使用）

	练习：
	1. 创建变量分别保存学生的年龄，入学成绩，身高，体重，并且输出到控制台上
	2. 创建变量分别保存学生的性别，姓名，电话，邮箱，并且输出到控制台上
	3. 创建变量保存 今天是否下雨？ 天是否冷？

2. 引用类型
********************************************************************
1. 数据类型转换
     1. 弱类型
	1. 声明时候，不需要指定数据类型
	2. 由 值 来决定变量的数据类型
	
	查看变量的数据类型：
	typeof() 函数或 typeof运算符
	语法：
	  typeof(变量);
	  typeof 变量;
     2. 隐式转换
	不同类型的数据在计算过程中会进行自动转换
	var stuName="张三丰";
	var stuAge=15;
	console.log(stuName+stuAge);

	NaN：not a number 不是一个数字
	isNaN(value);
	    true: 不是数字
	    false: 是数字
	任何数据类型和string相加时，都为string
     3. 显示转换（强制转换）
	通过 转换函数 完成数据类型转换
	1. toString()
	   转换成字符串
	   var num=123;
	   num+"";
	2. parseInt(value)
	   将 value 转换成整数
	   能转则转，否则就是NaN
	   碰到第一个非数字字符就停止转换。
	   如果第一个字符就是非数字字符，就无法转换。

	   注意：在网页中接受用户的数据全部都是 字符串 类型
	3. parseFloat(value)
	   将 value 转换成 小数

           碰到第一个非数子字符，就停止转换
           如果第一个字符就是非数字字符，就无法转换，结果为NaN。
     4. 练习
	1. 输入框
	   var input=window.prompt("提示信息","默认值（可选）");
2. 函数
     1. 什么是函数
	函数（Function）,称为 方法（Method），过程（Procedure）。
	功能：是一段预定义好，并且可以反复被使用的代码块。可以半酣多条语句。

	预定义好：事先定义好，随用随取，不会再网页加载时执行。
	反复使用：代码复用，可以被多个元素所调用
	代码块：允许包含若干条语句

	其本质就是一个独立的功能体
     2. 定义函数（方法，过程）
	语法：
	  function 函数名称（）{ 若干条执行代码; }
     3. 调用
	在任何允许编写JS脚本的地方，直接通过 函数名称（） 进行调用

	console.log();
 	typeof();
	document.write();
	alert();
	prompt();
     4. 定义带参函数
	语法：
	  function 函数列表（参数列表）{

	  }

	  参数列表：由一个或多个参数名称组成，多个参数之间，用 ， 分割。
	  声明函数所定义的参数，称之为“形参（形式参数）”

	  console.log("hello world!");
	  prompt("input your salay","0");

	  调用带参函数：
	  函数名称（参数列表）；
	  调用函数时所传递进来的参数称之为“实参（实际参数）”
      5. 变量作用域
         作用域： 变量的作用范围

	 1. 局部变量
	    在某一具体函数中所声明的变量，称之为 局部变量，只有在当	    前函数内有效
	 2. 全局变量
	    在JS标签（文件）中，独立于任何函数所声明的变量，称之为  	    全局变量，在整个网页中，全都有效

	    注意：当全局变量与局部变量相冲突时，优先使用局部变量

	    声明变量时，如果不使用var关键字，那么声明的就是全局变量	    

3. 分支结构（选择结构）
   1. 流程控制
      程序=数据 + 算法
      
      数据：基本信息
      算法：解决一个问题的思路

      程序三大基本结构：
      1. 顺序结构
	 自顶向下执行
      2. 选择结构（分支结构）
	 根据条件选择某一块代码执行
      3. 循环结构
	 根据条件选择某一块代码反复执行

      流程图：以图形的方式描述程序的走向
	1. 圆角矩形
	   表示程序的开始与结束
	2. 平行四边性形
	   表示程序中的输入与输出
	3. 菱形
	   表示程序中的条件判断
	4. 矩形
	   表示程序中的数据的处理
   2. 分支结构
	1. what
	   1. 在不同的情况下有条件运行某些语句
		不满足时不运行 - if结构
	   2. 当满足某个条件运行某些语句
		不满足时，运行另外某些语句 - if...else结构
	2. 运算符
	   比较运算符
	   >,<,>=,<=,==,!=
	   以上 运算符 运算结果为 boolean 类型
	3. if结构
	   1. 语法
	      if(条件){
		语句1；
		语句2；
		...
	      }

	      条件： 是一个boolean 类型的值

	      流程：
		1. 判断条件，条件如果为真，则执行语句块内容，为假，		则反之
		2. 继续往下执行
	    2. 注意
		1. 条件 必须 为boolean
		   如果为非boolean类型的数据作为条件，则会自动转换
		   以下情况下回自动转换为false
		   if(0){}
		   if(0.0){}
		   if(null){}
		   if(undefined){}
		   if(""){} 中间无东西，有则为真（包括几个空格）
		   if(NaN){}
		2. if（条件）{}大括号可以省略
		   如果省略大括号，if语句这只能控制它下面的一条语句
		   建议：尽量不要省略大括号
	4. if...else结构
	   1. 语法
	      if(条件){
		语句块1；
	      }else{
		语句块2；
	      }
	5. 多重if结构
	   问题
	   手动录入一个考试成绩
	    成绩为100分，奖励一台兰博基尼
	    成绩>=90分，奖励一台法拉利
	    成绩>=80分，奖励一台奥迪
	    成绩>=70分，奖励一台奥拓
	    成绩>=60分奖励一台永久牌自行车
	    否则 奖励两大嘴巴子。
	    
	    语法：
		if(条件1){
		  语句块1；
    		}else if(条件2){
		  语句块2；
		}
		...
		else{
		  语句块n;
		}
	
          6. 练习
	     使用 多重if结构 实现：根据克莱托指数输出 胖 瘦 正常 效果 
 	     公式： 克莱托指数=体重（kg）/(身高（m）*身高（m）)
	     结果：
		指数<20:偏瘦
		指数>25:偏胖
		否则 正好

*************************************************
                                第三天
1. 循环结构
   1. 问题
      1. 控制台上输出一句hello world
      2. 控制台上输出10句hello world
      3. 控制台上输出1000句hello world
      4. 将1000句hello world改为“你好世界”
      5. 将1000句的“你好世界”之前，加上第n遍输出
   2. 循环
      1. 什么是循环
	 循环就是一边又一边反复的执行相同或相似的代码行为

	 生活中的循环：
		1. 上学
		   做的事情：学习新知识
		   时间：6月底 - 10月底
		2. 5000米长跑
		   做的事情：跑
		   多少圈：12.5圈
		3. 地球的公转自转
		   做的事情：转
		   
	循环的两大特点：
	   1. 循环操作 - 循环体，要做的重复的事情是什么。
	   2. 循环条件 - 循环的执行次数
      2. 循环结构 - while循环
	 while : 当...时候
	 语法：
	　　　while(条件){
		循环体
	      }
	 流程：
	    1. 判断条件，如果条件为真，则执行循环体，再回来判断条件	               ，如果条件为真，继续执行循环体，再回来判断条件...
	       直到条件为假时，停止循环。如果条件为假，则一次循环也	               不执行
      3. 循环的流程控制语句
	 1. break
	    提前终止循环结构
	
	    作用：可以作为灵活结束循环的条件，可以多数用于 不确定循	    环次数的时候来结束循环
      4. 循环结构 - for循环
	 1. 打印1-10之间所有的数字
	    var i=1;		//声明语句
	    while(i<11){	//判断语句
		console.log(i); //循环语句
		i++;		//控制语句
	    }
	 2. for 循环
	    将while中的几个重点提出来，整合到一起形成的一种独立的循	    环结构
	    1. 语法
	       for(表达式1；表达式2；表达式3){
			//循环操作
	       }
		表达式1：声明循环条件
		表达式2：循环条件的判断
		表达式3：更新循环条件
	    2. for循环的执行过程
	       1. 计算表达式1的值
	       2. 计算表达式2的值
	       (boolean),如果是true，则执行循环操作，否则退出循环
	       3. 执行循环操作
	       4. 计算表达式3的值
	       5. 通过与表达式2的值 进行判断，决定是否继续进行循环
	    3. for的特殊用法
	       1. for与while的使用场合
		  确定循环次数时，优先使用for，不确定循环次数时，优		  先使用while
	       2. for的三个表达式的特殊用法
		  1. 省略表达式1
		     var i=1;
		     for(;i<=1000;i++){
			console.log(i);
		     }
		     省略时，一定要在循环的外部，将表达式补齐。
	          2. 省略表达式2		
		     for(var i=1;;i++){
			console.log(i);
		     }
		     死循环
		     最好在循环的内部，将条件补充完整，配合break一起		     使用
		  3. 省略表达式3
		     死循环
		     最好在循环的内部，将条件补充完整
		  4. 省略所有表达式
		     for(;;){
			
		     }
		     死循环
		  5. 表达式1和表达式3的位置处，可以声明多个表达式，		     用“，”隔开
2. 数组（创建和访问）
   1. 问题
      保存 WEB1606班所有同学的姓名，偶尔打印输出......
   2. 数组
      1. what
	 一组数据
	 
         多个元素所组成的集合在一个变量中保存多个数据的值

	 在内存中，数组是按照“线性”顺序进行排序的
	 线性：
	     除第一个元素以外，每一个元素都有唯一的前驱元素
	     除最后一个元素外，每一个元素都有唯一的后继元素

	 数组中是通过元素所在位置（下标/索引）来访问和标志元素的。
      2. 数组的定义与初始化
	 var 变量名=[];//声明一个空数组
	 var 变量名=["阿童木","机器猫"];//声明一个默认包含2个元素的	 	 数组；
	 var 变量名=new Array（）;//声明一个空数组
 	 var 变量名=new Array（"阿童木","机器猫"）;//声明一个默认包		 含2个元素的数组；
      3. 访问数组的元素
	 1. 设置数组元素的值-SET操作
	    语法： 数组名[下标]=值;
	 2. 获取数组元素的值-GET操作
	    语法： 数组名[下标]
	 3. 属性：数组的长度
	    属性： length
	    语法： 数组名称.length
	    数组长度： 数组中元素的个数
	 4. 循环遍历数组中的每一个元素

*************************************************
                                第四天
回顾
  1、循环结构
     1、循环特点
        1、循环操作
	2、循环条件
     2、什么是循环
        反复执行相同或相似的代码
     3、循环结构-while
        1、语法
	   while(条件){
	     循环操作;
	   }
	2、流程控制-break
	   提前结束循环操作
     4、循环结构-for
        1、语法
	   for(循环条件声明;条件判断;更新循环变量){
		循环操作;
	   }
	2、while 与 for
	   1、while
	      优先适用于不固定循环次数的循环中
	   2、for
	      优先适用于固定循环次数时
	3、for 表达式的特殊用法
	   1、可以省略各个表达式
	   2、表达式1和表达式3 支持 多表达式的写法
  2、数组(创建和访问)
     1、什么是数组
        在一个变量中保存多个数据
	通过 “下标” 来管理数组中的数据(元素)
     2、声明数组
        var 数组名=[];//空数组
	var 数组名=[数据1,数据2,...,数据n];

	var 数组名=new Array();
	var 数组名=new Array(数据1,数据2,...,数据n);
     3、数组的使用
        1、下标
	   标识数组中的每一个元素
	   从 0 开始
	   到 .length-1

	   设置或获取数组元素：
	   数组名称[下标];
	2、SET 
	   数组名称[下标] = value;
	3、GET
	   数组名称[下标];
	4、属性-length
	   获取数组的长度，即数组中元素的个数
	   语法：数组名称.length;
*******************************
1、DOM概述
   1、DHTML
      D : Dynamic -> 动态的
      DHTML : 动态的HTML
      将 HTML+CSS+Javascript 整合
      DHML功能：
        1、动态改变页面元素
	2、与用户进行交互
	3、DHTML对象模型中包含 BOM 和 DOM
      1、BOM
         Browser Object Model
	 浏览器对象模型
	 让JS有能力与浏览器进行对话
	 BOM提供了一组属性和方法 用于方便操作浏览器
	 没有相关的标准，但支持性较好
      2、DOM
         Document Object Model
	 文档对象模型
	 让JS有能力与HTML文档进行对话
	 DOM提供了一组属性和方法 用于操作 HTML文档及其所有元素的。
	 DOM标准由 W3C来定义
   2、DOM
      1、DOM概述
         W3C DOM标准被分成3个部分
	 1、核心DOM
	    DOM Core
	    提供了针对任何结构化文档的标准模型
	    结构化文档：HTML，XML
	 2、XML DOM
	    针对 XML 文档所提供的标准模型
	 3、HTML DOM
	    针对 HTML 文档所提供的标准模型
      2、发展历程
         1、DOM1级规范
	    底层结构，所有浏览器都兼容
	 2、DOM2级规范
	    1、DOM 2 Core ：基于DOM1扩展更多的属性和方法
	    2、DOM 2 Style ：提供了专门操作HTML样式的 属性和方法(Application Programming Interface : API)
	    3、DOM 2 Traversal and Range 提供了专门遍历 DOM树结构的 API
	    4、DOM 2 Event：标准化事件。IE8不支持。
	 3、DOM3级规范
      3、节点树-DOM树
         1、what
	    以 树状 结构表示 html中的所有的元素信息

	    html文档中的元素，属性，文本，注释 都被看做一个节点。

	 2 、详解
	    1、document 对象 为根节点
	       1、浏览器内置的JS解释器会为每个 网页 自动创建一个 document 对象

	       2、通过 document 对象 ，获取页面中的任何一个节点元素进行访问
	    2、
	      1、整个文档 是个 文档节点
	         (document node)
	      2、每个元素 是个 元素节点
	         (element node)
	      3、每个属性 是个 属性节点
	         (attribute node)
	      4、每段文本 是个 文本节点
	         (text node)
	      5、注释节点
	         (comment node)
2、选取元素
   1、通过HTML 选取页面元素
      1、通过 ID 选取页面元素
         document.getElementById("id");
	 返回：页面指定id的元素对象
      2、通过标签名选取页面元素
         element.getElementsByTagName("标签名");
	 返回：返回一组元素（数组）
      3、通过元素class属性选取页面元素
         element.getElementsByClassName("className");
	 返回：一组元素（数组）
      4、通过节点关系选取元素
         1、属性：parentNode
	    作用：获取当前元素的父节点元素
	 2、属性：childNodes
	    作用：获取当前元素的所有子节点元素(数组)
	 3、属性：firstChild
	    作用：获取 当前元素的 第一个子元素
	 4、属性：lastChild
	    作用：获取当前元素的 最后一个子元素
	 5、属性：previousSibling
	    作用：获取当前元素的 上一个兄弟节点元素
	 6、属性：nextSibling
	    作用：获取当前的下一个兄弟节点元素

	 ************************
	 1、属性：children
	    作用：获取 当前元素中的 所有 子级 [元素节点]
	 2、属性：firstElementChild
	    作用：获取 当前元素中 第一个子级 [元素节点]
	 3、属性：lastElementChild
	    作用：获取 当前元素中 最后一个 子级[元素节点]
	 4、属性：previousElementSibling
	    作用：获取当前元素的上一个 兄弟 元素节点
	 5、属性：nextElementSibling
	    作用：获取当前元素的下一个 兄弟 元素节点
3、读取和修改节点对象(文本，属性，样式)
   1、元素的文本
      1、HTML文本内容
         1、属性
	    innerHTML

	    作用：获取 或 设置 元素的 html内容
      2、普通文本内容
         1、属性
	    textContent
	    作用：获取 或 设置 元素 文本内容
   2、元素的属性
      1、属性集合
         作用：获取 当前 节点的属性集合
      2、属性
         attributes
      3、读取属性
         1、elem.attributes[下标].value
	 2、elem.attributes["属性名"].value;
	 3、elem.getAttributeNode("属性名").value;
	 4、elem.getAttribute("属性名");
      4、修改属性
         1、elem.setAttribute(name,value);
	 2、elem.setAttributeNode(attrNode);
   3、元素的样式
      1、CSS样式分类
         1、内联样式
	 2、内部样式表
	 3、外部样式表
      2、访问元素的内联样式
         属性：style
	 返回：CSSStyleDeclaration，包含当前元素中的所有的内联样式
	 CSS属性名变形:
	   CSS:background-color
	   DOM:backgroundColor

	   CSS:border-right-color
	   DOM:borderRightColor

	   CSS:width
	   DOM:width

	 获取或设置元素内联样式：
	 1、获取
	    elem.style.属性名
	 2、设置
	    elem.style.属性名="值";
      3、访问元素的内外部样式表中的样式
         1、获取
	   DOM:
	     *     document.defaultView.getComputedStyle(元素对象).样式名称; 针对除IE外的全部
		 
	   IE
	     元素对象.currentStyle.属性
         2、设置属性
	    优先使用内联方式设置属性值

	    修改 内部或外部样式表中的值
	    1、获得包含属性的样式表对象
	       var sheet=document.styleSheets[下标];
	    2、获取 所有样式规则 集合
	       var rules=sheet.rules;
	    3、获取 目标样式规则 
	       var rule = rules[下标];
	    4、获取或设置 rule 的属性
	       rule.style.属性名

*************************************************
                                第五天
张东
zhangdong@tedu.cn


1. 什么是JavaScript
   
2. 变量
3. 数据类型

补：控制台
1. 多行代码:shift+回车
2. 找回以前执行过的代码：向上键
3. 清屏： 左上角圆形叉 clear
4. 控制台可以直接 输出结果
5. 字体大小：按住ctrl+鼠标滚轮
6. 窗口大小 右上角

*************************************************
4. 数据类型转换
   1. 隐式转换：程序根据自己的需要，自动转化数据的类型
   2. 强制转换：由程序员主动调用函数执行的转换
	1. 何时：当隐式准换的结果，不是想要的时候
	2. 如何转换：
	   1. 一切转字符串：x to string:2种
	      1. x.toString(); 不能转null和undefined
		原因：null和undefined表示空什么都没有，无法加载.调用函数
	      2. String(x);  万能 ------ 首选
		一般采用这个，可转null和undefined
		if(x===undefined){
		   return "undefined";
		}else if(x==null){
		   return "null";
		}else{
		   return x.toString();
		}
	   2. 任意类型转number:x to number
	      1. **非字符串内容转number
		 var num=Number(x);
		 其实：Number也可以转纯数字组成的字符串
		
		 bool ->true - 1 false - 0
		 如果转不了，返回NaN：
		 NaN： not a number  是number类型，代表所有无效数字的值
	      2. 字符串转number:str字符串
		 parseInt(str); --- 取整
		 原理：从str开头开始读取每个字符跳过开头的空字符，碰到第一个非数字字符结束
		 如果转入的参数不是字符串，首先转为字符串，再读取内容
		 问题：不认识小数点---去掉小数部分
	         何时：只有在非常确定的要去掉小数部分时。
		 parseFloat(str) --- 首选
			原理：同parseInt 认识第一个小数点
		 自动判断转换后的类型，优先存为整数

		 如果无法转为数字，转为NaN
	    3. x to boolean:Boolean(x);
	       转换规则：只有5个值会被转为false:
		"  " 0 NaN null undefined
	       除此之外，都转为true
		Boolean([]); --> true 空数组
5. ***运算符和表达式
***程序：人的想法在计算机中的执行
运算符：程序中，模拟人的想法的符号
表达式：数据，变量，运算符组成的公式

  1. 算术运算符：+ - * / %
	何时使用%：1. 判断能否整除 2. 限制计算的结果不能超过最大值
	隐式转换：
	    默认：一切转为数字，再算数计算
		如果无法转为数字，则转为NaN:NaN在任何算数计算中，结果都是NaN
	    特殊：+运算中，碰到字符串，一切转为字符串，+运算符转为字符串拼接
	    var n1=2,n2=3,
s1="2",s2="3",b1=true,b2=false;
	    
console.log(n1*n2,s2-n1,s1-b1,b1+b2,s1+b2,n1+s2,n2/s1)



	    6 1 1 1 "2false" "23" 1.5
  2. 关系运算：作比较，做判断
     > < >= <= != ==
     返回值：true,false
     隐式转换：
	默认：一切都转为数字，再比较
	特殊：
	    1. 如果转不了，会转为NaN比较：
		NaN不大于，不小于，不等于任何值
    		无法用普通的==判断是否是NaN
		解决：isNaN(num)  判断num是否是NaN，结果true/false，如果true，num是NaN
		false，num不是NaN，是数字
		反着用：！isNaN(num) true->是数字，false->不是数字
	    2. undefined和null
	       问题：undefined==null -> true
	       ==中undefined隐式转为null
	       解决：全等=== -> 不带隐式转换的==
		要求：数据类型必须相等，其次值相等
		     undefined===null -> false
	 	何时使用：不希望比较时，自动隐式转换时--要求类型也必须相同时
		尤其：在和undefined和null比较时
	    3. 如果参与比较的都是字符串：
		按位PK字符串的unicode号，如果前一位相同，就比下一位，如果前几位都相同，比长度

	    4. 如果两个引用类型的对象做==比较，比较的是对象的地址
		比如：[]==[] -> false
		[]表示创建一个新数组的意思，有两个[]，就创建了两个新数组，两个新数组的地址不一样
  3.逻辑运算：将多个关系运算，综合得出最终结论
	&&（而且）  ||（或）  ！（非）
	如何使用：
	    条件1&&条件2：只有两个条件同时为true，才为true,只要一个为false，则false
	    条件1||条件2：只有两个条件同时为false，才为false,只要一个为true，则true
	    !条件：相反
	隐式转换：将每个条件临时转为boolean
	***短路逻辑：如果前一个条件已经可以得出最终的结论的时候，则后续条件不再执行（即使写错）
	  如何利用短路逻辑：
		1. 利用 && 短路逻辑：实现简单分支：
		   一个条件，一件事，满足就做，不满足就不做。--只能简化if结构
		   条件&&（操作）
		   条件是true,执行操作，条件是false,不执行
	        2. 利用 || 短路逻辑：实现两个值自动选择有效的值使用。
		   值1||值2：
		   如果值1有效（只要不是5个值之一），就返回值1
		   如果值1无效（值1是5个值之一），就返回值2.

	注意：参与逻辑运算的左右是两个确切的值，则其返回值不再是true和false，而是两值之一。
  			


课堂练习：
	运算符优先级

1. 位运算
   1. 左移和右移
	左移  <<  m<<n 等于m*2的n次方 ==== m*Math.pow(2,n)
	右移  >>  m>>n 等于m/2的n次方
   2. 取整
	parseInt(m)    m^0  m|0  m>>>0

扩展赋值运算：对赋值运算的简写
	m+=n => m=m+n 累加
	m-=n => m=m-n 
	m*=n => m=m*n
	m/=n => m=m/n
 	m%=n => m=m%n

	如果n是1：递增1 递减1 => m++ m--
	m++  ++m m--  --m
	单用一样效果，如果递增/递减运算参与到其他表达式中，前++与后++不同
	相同点：变量中的值一定都加1
	n=m++ 先调用m输出,在给m+1
	n=++m 先给m+1，再输出m

作业：
var n=3;
console.log(
n++ + ++n + n++ 输出？ 
++n + n++ + ++n 输出？
)

作业：第2,4,5题	

*************************************************
                                第六天
回顾: 
1. 递增/减
 n++ => n+=1 => n=n+1
 n-- => n-=1 => n=n-1
  前++ vs 后++
 单独使用: 前++或后++都一样
 如果参与其他表达式中: 
   相同: n一定被+1
   不同: 前++，返回新值
         后++，返回旧值
 鄙视题:
  var n=3;
  n++ + ++n + n++
  →

犀牛书:
微信公众号: 前端大全
js1k:

正课:
1.***函数:
2.全局函数:了解
3.分支结构:

1.***函数:
  什么是函数: 封装一项任务步骤清单的代码段，再起一个名字。
  为什么: 直接在全局编写的代码无法重复使用，只能反复编写多次。
  何时: 只要一段代码，可能被反复调用执行，就都要先保存在一个函数中，再反复调用函数即可。
  优: 代码重用
  如何使用: 
    声明:创建一个函数对象，封装一项任务的步骤清单
      function 函数名(参数列表){
	步骤清单代码段;
        return 返回值;
      }
    参数: 执行函数时必须的数据列表
       本质: 其实就是一个普通的变量
             专门接收调用函数时，传入的必要数据。
       何时: 当一项任务必须某些数据才能正常执行时，就必须定义参数。
       作用: 让程序变的更灵活
    返回值: 函数的执行结果
       何时: 如果调用者需要获得函数的执行结果时，函数内就必须定义返回值。
       return只负责返回结果，不负责保存结果。

    存储: 函数名就是一个普通的变量
      函数定义是一个函数对象
      函数名变量通过地址，引用函数对象

    调用: 让引擎找到指定名称的函数，按照函数体执行程序
      var 返回值=函数名(参数值列表);
  ***强调: 函数只有调用才执行，不调用不执行。
      如果函数没有返回值，可省略之前的=
      如果函数有返回值，就必须声明变量保存住返回的值。
      参数值列表: 顺序和个数都要和定义时的参数列表保持一致。

***作用域(scope): 一个变量的可用范围
       本质: 内存中存储变量的对象
  2种: 
   全局作用域:window 保存所有全局变量和函数的对象。
      全局变量: 不属于任何函数的，直接定义在全局的变量。
          特点: 随处可用，可反复使用
            缺: 极容易被污染
             所以，尽量少用全局变量。
   函数作用域: 保存函数中局部变量的对象
      局部变量: 在函数内声明的变量
         2种: 
          1. 在函数内var的变量
          **2. 参数变量，也是局部变量
         特点: 局部变量，出了函数，不可用
变量的使用顺序:
   优先使用局部变量
   如果局部没有，去全局找
   如果全局找不到，就会报错

***声明提前(hoist):
  在程序开始执行前，
  将var声明的变量和function声明的函数，提前集中到当前作用域的顶部声明
  赋值留在原地
  
***按值传递(byValue):
  两变量间赋值时，或将变量作为参数传入函数时，其实只是将原变量中的值复制了一个副本给对方
   结果: 
     变量是原始类型的值:
      在函数内修改新变量，不会改变原变量       变量是引用类型的对象:

回顾:
***按值传递:
  两个变量间赋值时，或将变量作为参数传入函数时，其实只是将原变量中的值复制一个副本给对方.
  结果：
   原始类型的值: 
     修改新变量，不会影响原变量
   引用类型的对象:
     通过新变量修改对象，等效于直接修改原对象。

正课:
1. 全局函数:了解
2. 分支结构:

1. 全局函数: 了解
 ES标准中规定的，浏览器厂商已经实现的，不需要任何对象就可直接调用的函数
  手册->javascript->javascript对象->js functions->全局函数列表
  鄙视时: 
   只有在前9天讲的不需要任何对象就可调用的函数就是全局函数。
   后五天讲的都不是。

 编码解码: 
 问题1:URI标准中不允许出现多字节字符
      比如: 汉字
 解决1:将URI中的多字节字符编码为单字节字符
      用utf-8编码:
   发送方需要将多字节编码为单字节
   如何编码: var code=encodeURI(str)
   接收方需要将单字节的编码解码为原文
   如何解码: var str=decodeURI(code)
 问题2:URI标准中不允许使用保留字符:
      比如: : /
       且encodeURI和decodeURI无法编码解码保留字符。
 解决2:
   编码: var code=encodeURIComponent(str)
   解码: var str=decodeURIComponent(code)

 eval(str): 执行字符串格式的程序
   强大: 解析字符串格式的数据结构:
        比如: 对象，数组

 isFinite(num): 判断num是否在计算机可表示的有效范围内.
  问题: js中除数为0，不会报错，会返回infinity.
  如何判断一个计算的结构是不是infinity
    isFinite(num)

2.分支结构:
   
作业:1,11,12,13,14,16,21,22
 
*************************************************
                                第七天
1.***数组
 什么是数组:内存中连续存储多个数据的存储空间，再起一个名字。
            一组连续的变量的集合
 为什么: 
   程序=数据结构+算法
     数据结构: 数据在内存中的存储结构
     算法: 解决一个问题的步骤
 良好的数据结构可以极大提高程序的执行效率
 何时: 今后，只要保存多个相关的数据，都要用数组。
 如何: 
   创建: 
     1. 创建空数组: 
        var arr=[];//创建一个新数组的意思
        var arr=new Array();
               新建 数组
       何时: 如果创建数组时，暂时不知道具体的数组元素。
     2. 创建数组同时，初始化数组元素: 
        var arr=[值1,值2,...];
        var arr=new Array(值1,值2,...);
       何时: 如果创建数组时，已经知道所有元素的值。
     3. 创建n个空元素的数组:
        var arr=new Array(n);
   赋值/取值都要用下标: 
     下标: 数组中唯一标识一个元素的序号
       自动分配的数字下标: 
	从0开始，递增，连续不重复
   赋值: arr[i]=值;
     特殊: 如果arr中i位置没有元素，会自动创建新元素。
     稀疏数组: 下标不连续的数组
   取值: 数组中每个元素的用法和普通变量完全一样！
    如果访问数组中一个不存在的下标位置，不会报错，会返回undefined！
   
   vs 其他语言中的数组: 3不限制:
     1. 不限制元素个数
     2. 不限制元素的数据类型
     3. 不限制下标越界

  属性: arr.length: 表示数组中理论上的元素个数。
   arr.length始终等于最有一个元素的下标+1
   固定套路: 
   1.获得最后一个元素: arr[arr.length-1]
   2.获得倒数第n个元素: arr[arr.length-n]
   3.末尾追加: arr[arr.length]=值
   4.缩容: arr.length-=n，减小数组容量
         超出的元素会丢弃
     比如: 删除最后一个元素: 
         arr.length-=1

 数组是引用类型的对象: 
   垃圾回收: js引擎会自动释放不再被任何变量引用的对象。
   垃圾回收器: js引擎中的小程序，专门负责记录内存中对象的引用次数，并删除不再被引用的对象。
     伴随主线程在后台自动执行。
   建议: 今后只要使用完较大的对象，都要主动赋值为null，释放对对象的引用。
   当所有变量都释放对一个对象的引用后，对象被垃圾回收。

  遍历索引数组: 
   for(var i=0;i<arr.length;i++){
      arr[i]//当前元素
   }

  索引数组: 下标为数字的数组都是索引数组
  关联数组(hash数组):
  什么是: 可自定义下标名称的数组
  为什么: 索引数组中的下标是无意义的数字
    [林心如, 81,  56,  86]
      name  math  chs  eng
  何时: 只要希望每个元素有明确的意义时
  如何创建: 2步:
    1. 创建空数组: var lxr=[];
    2. 向空数组中添加元素，为每个元素定义元素名。
       lxr["name"]="林心如"
  取值/赋值: 每个元素的取值和赋值和索引数组的用法完全相同。只不过下标变为有意义的名称字符串。
  强调: 关联数组中length属性失效！
  遍历关联数组: for in循环
   for(var key in arr){
      arr[key]//当前元素
   }
   in: 依次取出arr中每个元素的下标名称，保存在变量key中

  hash数组的原理: 
   hash算法: 专门接收一个字符串，计算出一个尽量不重复的序号。
    相同字符串，先后计算出的序号一定相同
   存储: 根据元素的名称，计算出一个序号
       将元素值保存到指定序号的位置上
   取值/查找: 用提供的元素名，计算出和存储时完全相同的序号，直接到序号所在位置获取元素值。
   优: 查找速度极快：
      不用遍历，查找速度和元素个数，以及存储位置无关！
   vs 索引数组: 只能靠遍历查找，查找速度慢，受元素个数和元素存储位置的影响极大。

2. ***数组常用API: 
  1. 转字符串: 
   String(arr): 将每个元素都转为字符串，用","相连。――拍照 用于判断数组是否发生变化
   var str=arr.join("连接符"): 
      将每个元素都转为字符串，用自定义的"连接符"相连。
   固定套路: 
   1. 无缝拼接: arr.join("")
        如果省略""，就和String等效了
   2. 将单词拼接成句子: 
	arr.join(" ")
   3. 将数组元素，批量生成页面元素:
        "<标签>"+
        arr.join("</标签><标签>")+
        "</标签>"
  2.连接和截取子数组: 
   连接: var newArr=arr1.concat(arr2);
        将arr2拼接到arr1之后，返回新数组
     强调: concat无权修改原数组，只能返回新数组，必须用变量接住拼接的结果。
     其实: .concat(值1,值2,arr2,....);
       其中: .concat可以打散数组类型的参数为单个值。

   截取子数组: 
     var subArr=arr.slice(starti,endi+1);
     截取arr中starti位置开始到endi位置结束的子数组。
     强调: 也无权修改原数组，只会复制子数组。
     强调: API中同时出现开始位置和结束位置时，都是含头不含尾。
     变化: 1. 省略第二个参数，表示截取到结尾。

 3.颠倒数组元素: arr.reverse();
     直接修改原数组。
  
*************************************************
                                第八天
回顾:
***数组API:
 1. 转字符串:
  String(arr)
  arr.join("连接符")
 2. 拼接和截取:
  var newArr=arr1.concat(值1,值2,arr2,..)
  var subArr=arr.slice(starti,endi+1)
 3. 颠倒数组:
  arr.reverse();

正课:
1.***数组API
  splice
****sort
  栈和队列
  二维数组
2.***String

1.***数组API
 splice: 删除，插入，替换
   删除: arr.splice(starti,n)
     删除arr中starti位置开始的n个元素
     强调: n是个数，不考虑含头不含尾
     其实splice可返回删除的元素组成的临时数组。
     var deletes=arr.splice(starti,n)
   插入: arr.splice(starti,0,值1,值2,...)
     在arr的starti位置插入值1,值2,...
     原starti位置及其之后的值，都被向后顺
移
     强调: 0 表示不删除，只插入新值
          不支持打散数组类型参数。
            如果传入数组，会形成子数组
       vs concat: 
         concat: 优: 打散数组类型参数
                 缺: 只能拼接在开头或结尾
         splice: 优: 可指定插入位置
                 缺: 不支持打散数组参数
  替换: var deletes=
         arr.splice(starti,n,值1,值2,...)
       先删除starti位置开始的n个，再在starti位置插入值1,值2。
      强调: 删除的元素个数，和插入新值得个数，不必一致。

 ****sort: 
  自定义: 冒泡，(快速，插入)――手写
    原理: 
  API: arr.sort();
   将arr中的元素按升序排列
   问题: 默认将所有元素转换为字符串再排列
   为什么: js中的数组不限制元素的类型
        为了保证sort方法正常执行，默认将所有元素转为字符串，再比较unicode。
   所以，默认的sort方法，只能排序字符串元素
  如果排序非字符串类型的元素: 2步
    1. 自定义比较器函数
    比较器函数: 专门比较两个值大小的函数
      如何定义: 
        参数: a,b 分别接收要比较的两个值
        返回值: 如果a>b,就返回正数
                否则，如果a<b,就返回负数
                否则，就返回0
      专门比较两个数字大小的比较器:
       function compare(a,b){
	 return a-b;
       }
      专门比较两个字符串长度的比较器:
       function compare(a,b){
	 return a.length-b.length;
       }
    2. 将比较器函数传入sort方法作为比较大小的依据。
       arr.sort(compare);

  补: 其实，函数有第二种创建方法:
   var 函数名=function(...){...}
   何时使用: 只要不希望被声明提前时
  vs function 函数名(...){...}
   只有一点差别: 
    function 函数名 会被声明提前，
    var 函数名=function 不会被声明提前

  降序: 颠倒比较器的正负号，可改升序为降序。
    
 *************************************************
                                第九天 
数组API:
 1. 转字符串: 
   String(arr)
   arr.join("连接符")
 2. 拼接和截取:
   var newArr=
	arr1.concat(值1,值2,arr2,...);
   var subArr=arr.slice(starti,endi+1);
 3. 翻转: arr.reverse();
 4. splice:
   删除: var deletes=arr.splice(starti,n)
   插入: arr.splice(starti,0,值1,值2,...)
   替换: arr.splice(starti,n,值1,值2,...)
 5. 排序:
    arr.sort();
    定义比较器函数:
    function compare(a,b){return ?-?}
    arr.sort(比较器函数对象)
    颠倒比较器结果的正负可改升序为降序
 6. 栈和队列:
   栈: FILO
    1. 结尾: 入:arr.push(值)
             出:var last=arr.pop();
    2. 开头: 入:arr.unshift(值)
             出:var first=arr.shift();
   队列: FIFO
    结尾入: arr.push(值)
    开头出: var first=arr.shift();

字符串API:
1. 下标访问每个字符
2. length属性记录字符个数
3. 拼接和截取: concat和slice
4. 大小写转换: 
    str.toUpperCase();
    str.toLowerCase();

正课:
1.***String:
***检索关键词:
  *****正则表达式:
  替换:
    扩展:删除，格式化
  切割: 

***检索关键词: 4种: 
  1. 检索一个固定的关键词的位置:
   var i=str.indexOf("关键词",fromi)
   在str中查找fromi位置后，下一个"关键词"的下标位置。
   简写: 省略fromi，表示从0位置开始
   返回值: 本次找到的关键词第一个字符在字符串中的下标位置。
      如果没找到，返回-1
   var i=str.lastIndexOf("关键词",fromi)     在str中查找fromi位置前，上一个"关键词"的下标位置。
   简写: 省略fromi，表示从末尾位置开始
   缺: 只能找固定的一个关键词。

  2. 判断是否包含符合规则的关键词：
     支持正则: 
    var i=str.search(/正则表达式/);
    查找str中第一个关键词的位置 
    返回值: 如果找到，返回下标位置
            如果没找到，返回-1

*****正则表达式:
 规定字符串中字符出现的规律的规则。
 何时使用: 只要按规则模糊检索关键词时
 如何定义: 
  1. 最简单的正则表达式：关键词原文
  2. 字符集: 规定一位字符可用的备选字符列表。
      何时: 只要一位字符，有多种可能时，都要将备选字符定义在一个字符集中。
      如何: [字符列表]
       强调: 所有字符连续排列，不需要分割
             一个字符集，只能修饰一位字符
             一个字符集中必须且只能选一个
    网址: regexper.com
      简写: 如果字符集太长，且连续: 
            用-省略中间的字符:
            1位字母:[A-Za-z]
            1位数字:[0-9]
            1位汉字:[\u4e00-\u9fa5]
      特殊: "除了xxxx" : [^xxx]
             比如: 除了4和7 [^47]
           强调: ^必须放在[]内的开头
  3.预定义字符集:常用字符集的简化:
    4个: 1位数字: \d =>[0-9]
         1位数字，字母，_: \w 
			=> [0-9A-Za-z_]
         1位空字符: \s 空格 换行 Tab
    强调: 预定义字符集只有在和规则完全匹配时，才能使用。
      如果规则和预定义字符集不完全匹配，就必须自己定义字符集。
     
         1位任意字符: .
  4. 量词: 固定一个字符集出现次数的规则
    1. 有明确数量边界的
      字符集{m,n} 字符集最少m个，最多n个
      字符集{m,}  m个以上
      字符集{m}   必须m个
    2. 没有明确数量边界的
      字符集?  可有可无，最多1个
      字符集*  可有可无，个数不限
      字符集+  至少1个，多了不限
  5. 选择和分组:
    选择: 规则1|规则2  读作"或"
      在两个规则中匹配其一即可。
    分组: 将一组规则，用()包裹
  练习：手机号:   
    +86或0086  可有可无，最多1次
    空字符     可有可无，多了不限
    1
    34578
    9位数字
    (\+86|0086)?\s*1[34578]\d{9}
  6. 指定匹配位置: +$结尾之前的所有
    ^ 匹配字符串开头
      比如: 匹配开头的空字符: ^\s+$ 匹配字符串结尾
      比如: 匹配结尾的空字符: \s+$

    比如: 同时匹配开头或结尾的空字符
      ^\s+|\s+$

    \b 匹配单词边界: ^ $ \s 标点
      何时使用: 只要找单独的单词
   
正则:
 1. 关键词的原文就是最简单的正则
 2. 字符集: [备选字符列表]
    [0-9] [A-Za-z]   [^47]
 3. 预定义字符集: \d  \w   \s   .
 4. 量词: 
   {m,n}  {m,}   {m}
   ?      +      *
 5. 选择和分组:
   规则1|规则2
   (多个规则)
 6. 指定匹配位置： 
   ^    $    \b

预判: 提前判断字符串是否满足部分规则
 密码强度:
   1. 至少包含一位大写字母
      如果不都由小写字母和数字组成
      (?![a-z0-9]+$)
      说明可能包含大写字母或标点
   2. 至少包含一位数字
      如果不都由字母组成
      (?![A-Za-z]+$)
      说明可能包含数字或标点
   3. 6~8位字母，数字的组合
      [0-9A-Za-z]{6,8}
^(?![a-z0-9]+$)(?![A-Za-z]+$)[0-9A-Za-z]{6,8}$

正课:
1.***StringAPI:
  检索关键词:
  替换:
    延伸: 删除 格式化
  切割:

检索关键词: 
  1. 查找一个固定关键词的位置,可连续查找:
    var i=str.indexOf("关键词",fromi)
    var i=str.lastIndexOf("关键词",fromi)
   问题: 依次只能找一个固定的关键词，无法模糊查找。
  2. 判断字符串中是否包含符合规则的关键词
    var i=str.search(/reg/);
      如果i不是-1，说明包含。否则，不包含
    强调: 1. 不能连续查找   
          2. 正则本身区分大小写的
            如果忽略大小写: /reg/i
    问题: 1. 不能连续查找，永远找第一个
          2. 仅返回关键词位置，无法返回内容。
  3. 返回所有关键词的内容
    var kwords=str.match(/reg/i);
    查找str中和reg匹配的关键词内容。
    返回值: 保存所有关键词内容的数组
    ***如果找不到，返回null
        如果可能返回null，就必须先验证不是null，再操作。
    问题: 正则表达式，默认仅匹配第一个符合条件的关键词。不会匹配所有
    解决: /reg/ig
    缺: 无法获得每个关键词的位置。
  4. 即找每个关键词的位置，又找每个关键词的内容？

替换: 
  str=str.replace(/reg/ig,"替换值");
  将str中和reg匹配的敏感词替换为"替换值"
  强调: 不直接修改原字符串，而是返回新字符串。
  高级替换:
  str=str.replace(/reg/ig,
     function(kw,$1,$2,....){
	//kw 本次找到的关键词
	//$1 获得第1个分组()匹配的子内容
	//$2 ...
        return 替换值
     }
  )

 衍生:
  删除: 将找到的关键词替换为空字符串。
  格式化: 2步:
    1. 用正则将源字符串内容分组
    2. 在replace的替换值中，直接用$n代表第n个()的子内容。

切割: 将一个大的字符串，按指定字符分割为多个子字符串。
  var subs=str.split(/reg/);
  将str，按reg匹配的字符切割为多个子字符串，保存在数组subs中。
  强调: 在结果数组中，不包含分隔符

获得指定位置的字符: 
  str.charAt(i) => str[i]
  var code=str.charCodeAt(i) 
	=> 获得i位置字符的unicode号
  var char=String.fromCharCode(code)
        => 将unicode号，转为字符

截取子字符串:
  str.slice(starti,endi+1)
  str.substring(starti,endi+1)
    substring不支持负数参数
    变通: str.length-n
  str.substr(starti,n)
    从starti位置开始截取n个字符
    不考虑含头不含尾       

 *************************************************
                                第十天   
1.***RegExp: Regular Expression
  什么是: 封装一条正则表达式
          提供用正则表达式执行验证和查找的API。
  如何使用: 
    创建: 2种
     1. 正则直接量: var reg=/reg/ig
       何时使用: 在创建正则表达式对象时，就已经确定规则。
       特殊字符: 如果出现/，要转为\/
     2. 用new: 
	var reg=new RegExp("reg","ig");
       何时使用: 如果正则需要在运行时动态拼接而成。
       强调: "reg"不用加前后/
       特殊字符: \ " ' 都要转为\\  \"  \'
  RegExp API:
   1. 即找每个关键词的内容，又获得每个关键词的位置: 
     如何使用: 
      var arr=reg.exec(str);
    在str中查找和reg匹配的一下一个关键词
    如果找所有，要用循环推动
    原理: 
      1. 默认，reg会从头开始，查找str中下一个关键词的位置。
      2. 返回值: 
         arr:["完整关键词",$1,$2,...]
         arr.index:本次找到的关键词的位置
      3. 每次查找后，将reg对象的lastIndex属性改为当前位置+关键词字符个数。
         reg.lastIndex: 表示下次开始位置
      4. 如果找不到，就返回null
    在查询过程中，可用RegExp.$n直接获得本次找到的关键词的第n个分组子内容。

  课堂练习: 
    贪婪模式:正则表达式默认会匹配最长的符合规则的子字符串。
    懒惰模式:让正则只匹配最短的符合条件的子字符串
    贪婪改懒惰: .*? .+?
    其实也可用[^xxx]

  2. 验证: var bool=reg.test(str)
     如果str符合reg的格式要求，返回true
                          否则，返回false
     问题: 只要str中部分符合reg的要求，就返回true。但是验证都要求完整匹配
     解决: 验证时，必须前+^，后+$  
1.Math:
 强调：不能new
  1. 取整:
    上取整: 只要超过，就取下一个整数
	Math.ceil(num)
    下取整: 抹掉小数部分
        Math.floor(num)
    四舍五入取整:
        Math.round(num);
	  只能取整
          返回值是数字
     vs n.toFixed(d)
          可按任意小数位数四舍五入
          返回值是字符串
     自定义round(num,d)

  2. 乘方和开平方: 
    乘方 : Math.pow(底数,幂)
    开平方: Math.sqrt(num)

  3. 最大值和最小值:
    Math.max(值1,值2,...)
    Math.min(值1,值2,...)
    要比较的多个值，必须单独传入。不能放在一个数组中整体传入。
    如何获得数组中的最大值和最小值：
    Math.max.apply(null,arr)
    Math.min.apply(null,arr)

  4. 随机:
    Math.random() 生成一个0~1之间的小数
    min~max：
  parseInt(Math.random()*(max-min+1)+min)
    0~max:
    parseInt(Math.random()*(max+1));
    
2.Date: 
  封装一个时间，提供操作时间的API。
  原理: date对象中封装的是一个1970年1月1日0点至今的毫秒数。
  创建: 3种:
    1. 创建日期对象，并自动获得客户端系统时间:
    	var now=new Date();
    2. 创建日期对象，并自定义时间
var date=new Date("yyyy/MM/dd hh:mm:ss");
var date=new Date(yyyy,MM-1,dd,hh,mm,ss);
    3. 复制一个日期对象: 
       var date2=new Date(date1)

  Date API:
  单位:(分量)
   FullYear Month Date Day
   Hours Minutes Seconds Milliseconds
  1.每个单位，都有一对儿getXXX/setXXX方法
    其中getXXX负责获取指定分量的值
        setXXX负责修改指定分量的值
    特殊: Day星期  没有setXXX
  2.命名: 年月日星期 没有s
          时分秒毫秒 有s
  3.取值范围: 
    除了date(月中的日) 1~31
    其余都从0开始，到进制-1结束
    比如: 
     Month: 0~11 修改时，可能需要修正
     Day: 0~6 不用修正,周日是第一天
     Hours: 0~23 不用修正
     Minutes/Seconds: 0~59

  计算: 
   1. 两个日期可相减，结果是毫秒差
   2. 对任意分量做加减: 
     3步: 
      1. 取分量: var n=date.getXXX();
      2. 做加减: n+/-=?
      3. 放回去: date.setXXX(n)
        setXXX可自动调整进制 
     简写: date.setXXX(date.getXXX()+n) 

  转字符串: 
  date.toString(); 将date转为国际标准日期格式
  date.toLocaleString();转为当地时间格式
  date.toLocaleDateString(); 仅保留日期
  date.toLcoaleTimeString(); 仅保留时间

  自定义format函数:  


 *************************************************
                                第十一天

1. ***错误处理
2. *****Function
   创建
   重载
   匿名函数
   ****作用域和作用域链
   *****闭包

1. ***错误处理: 
  错误(bug): 程序执行过程中遇到的异常中断
    发生错误，程序会强行退出
  错误处理: 即使程序发生错误，也保证不会强行退出的一种机制
  如何处理: 
    try{
      可能出错的正常的语句
    }catch(err){
      只有出错才执行的错误处理代码,告诉人，记日志，保数据
    }finally{
      无论是否出错，都必须执行的代码
    }
    其中: err在出错时，自动获得错误对象
      即使不使用，也不能省略！
     错误对象:在发生错误时，封装错误信息的对象。
      Error:6种:
       SyntaxError: 语法错误
       ReferenceError: 引用错误
       TypeError: 类型错误
       RangeError:范围错误
       URIError,EvalError:URL相关函数参数错误，eval函数错误

    finally: 可省略

 问题:普通代码，放入try，执行效率会下降    所以，try中应该仅包含可能出错的代码
 解决:提前预知错误，使用if判断代替try结构

  关于try catch中的return
    finally中有return，会覆盖之前的所有return
    finally中没有return，程序会先确定之前return的返回值，但是，暂不返回。等待finally中的代码执行完，才返回。
      finally中的代码，不会影响之前确定的return结果。

  抛出自定义错误: 
   何时需要抛出自定义错误?
     如果函数的定义者，希望提醒调用者错误的使用了函数时。

2.*****Function
 创建: 3种：
   1.声明: function 函数名(xxx){...}
    只有声明方式创建的函数，才会被提前
   2.函数直接量: 
    var 函数名=function(xxx){...}
    何时使用: 只要不希望声明提前时
   3.用new: 
    var 函数名=
      new Function(
	"参数","参数",...,
	"函数体")

 重载(overload):
  什么是: 相同函数名，不同参数列表的多个函数，在调用时，可自动根据传入参数的不同，执行不同的逻辑。
  何时使用: 如果一项任务，需要根据不同参数，选择不同的逻辑执行时。
  优点: 减轻调用者的负担。
  问题: js的语法不支持重载！
  解决: 使用arguments对象
    什么是:专门接收调用时传入函数的所有参数值得类数组对象
      类数组对象: 长得像数组的对象-集合
         vs 数组: 
           相同: 1. 下标访问每个元素
               2. length属性表示元素个数
           不同: 1. 类型不同
                 2. 无法使用Array的API

匿名函数: 创建后，不被任何变量引用的函数
  只能用一次，不可重用
  何时使用: 如果一个函数，确定只使用一次
  优: 节约内存
  如何使用:
    1.自调: 函数定义完，立刻执行。
      划分临时作用域
    2.回调: 将函数定义后，传递给其它函数调用。

****作用域和作用域链:
 作用域(scope):一个变量的可用范围
 函数的生命周期: 
   1.程序开始执行时
     Execution Context Stack:
      执行环境栈: 专门按调用顺序保存每个函数的执行环境的集合。
      开始执行程序时，首先压入全局执行环境。
      创建window对象，保存所有全局函数和变量。其实window对象就是全局作用域对象。
   2.定义函数时
      创建函数对象，封装函数定义
      用函数名创建一个变量
      函数名变量引用函数对象

      在函数对象中添加scope属性:
        引用函数来自的作用域对象
        通常都引回window
   3.调用函数时
      创建活动对象(Actived Object):
        AO:保存函数调用时的局部变量
        其实AO对象就是函数作用域对象

        在AO中添加parent成员，引用函数来自的父级作用域对象
        由此形成作用域链。
        作用域链控制着变量的使用顺序: 
           优先使用局部的
           局部没有，才用全局的

      向ECS中压入本次函数调用的EC
      EC中的scope chain属性引用AO
   4.函数调用后:
      本次函数调用的EC出栈
      AO释放，局部变量一同释放

*****闭包: 
 即重用局部变量，又保护变量不受污染的机制
 为什么: 
   全局变量: 随处可用，可重复使用
         缺: 极易被污染
   局部变量: 不会被污染
         缺: 不可反复使用，只能在函数内使
用。
 何时使用: 如果希望一个变量可被反复使用，且不会被污染！
 闭包: 3步: 
   1. 用外层函数将变量和操作变量的函数包裹起来。
   2. 外层函数将内层函数对象返回
   3. 调用外层函数，获得内层函数对象

 鄙视中: 
   1. 先找受保护的变量，确定其值
      特殊: 变量的值很可能不是声明时的初始值――看外层函数调用结束时，n的值
   2. 找到操作变量的函数，确定如何操作
      特殊: 2种办法返回
       1. return fun
       2. 可能直接给全局变量赋值   

*************************************************
                                第十二天             1. 闭包:
  什么是: 重用并保护一个局部变量的机制
      因为，外层函数的作用域无法释放
  为什么: 
    全局变量  局部变量
  何时: 
    希望重用一个变量，又不希望被篡改时
  如何使用: 3步:
    1. 用外层函数包裹受保护的变量和操作变量的函数
    2. 外层函数将内层函数对象返回
    3. 使用者，调用外层函数获得返回的内层函数对象。

  鄙视:
  1. 找受保护的变量
  2. 找操作变量函数
  3. 同一次外层函数调用返回的所有内层函数对象，共用同一个受保护的局部变量
  4. 两次外层函数调用，返回的不同内层函数对象，所操作的变量，没有任何关系。
  闭包返回内层函数对象:
   1. return
   2. 直接给全局变量赋值
   3. 将内层函数封装在一个对象中，然后返回对象。

  闭包缺点: 占用更多内存空间
        且一旦形成闭包，无法自动释放。

正课:
1. *****面向对象
  对象: 1.描述现实中一个具体事物的属性和功能的程序结构
        事物的属性会成为对象的属性
        事物的功能会成为对象的方法
      2. 内存中同时存储多个数据和方法的一块存储空间。
  面向对象: 在程序中，都是先用对象封装一个事物的属性和功能。然后，再调用对象的方法，来执行任务。
  为什么: 符合人日常的习惯。
  如何使用: 2步:
  1.创建对象――封装: 2个
    1.创建一个单独的对象:
      1.对象直接量:
        var obj={
           属性名:属性值,
             ... : ...,
           方法名:function(){...}
        }
      何时使用:如果创建对象时，已经知道对象的所有属性和方法时。
      对象的属性和方法，统称为对象的成员
      对象中的每个成员名都是字符串类型
        但是，可省略""
    问题: 对象的方法中，不能写死对象的属性值
    解决: 在对象的方法中，直接访问当前对象自己的属性
      this关键词: 专门用在对象的方法中，用来指代正在调用方法的当前对象本身。
        其实就是调用方法时,点"."前的对象
    总结: 只要在对象的方法中，访问对象自己的属性，必须用this.属性名
      2.用new关键词:
       var obj=new Object();//创建空对象
              ={}
       obj.属性名=值;
       obj.方法名=function(){
	  ...
       }
       何时使用: 创建对象时，还不知道对象的属性和方法，需要后续动态添加。
*****js中一切对象都是关联数组
      相同: 1. 属性名都是字符串,不可重复
            2. 随时添加新属性和方法
            3. 可用for in遍历
    2.批量创建多个相同结构的对象
      2步:
      1. 定义构造函数:
        构造函数：专门定义一类对象统一结构的特殊函数。
        为什么: 代码重用
        何时使用：今后，只要反复创建多个相同结构的对象前，都要用构造函数先定义统一的结构。
        如何定义：
function 类型名/构造函数名(属性参数,..){
    //this:当前正在创建的空对象
    //向当前空对象中添加新的属性
    this.属性名=属性参数;
    //向当前空对象中添加新的方法
    this.方法名=function(){
      ...
    }
  }
      2. 用new调用构造函数创建新对象:
       var obj=new 构造函数名(属性值);
        new: 4件事: 
         1.创建一个空对象
         2.?
         3.用新对象调用构造函数
	   构造函数会向新对象中添加属性很方法。
	 4.将对象地址返回给obj
  2.访问对象的成员:
    访问属性: 对象.属性
      单个对象属性的用法和变量完全一样
    调用方法: 对象.方法(参数)
    	找到“对象”的“方法”，执行。
      单个对象方法的使用和函数完全一样 
1.*****面相对象:
  封装: 将现实中一个事物的属性和功能集中定义在一个对象中。
  如何封装: 2个场景
   1. 创建一个单独的对象:
     1. 直接量: var obj={
                  属性名:属性值,
                  方法名:function(){
		    ...this.属性...
                  }
                }
     2. 使用new关键词: 
         var obj=new Object();
         obj.属性名=属性值;
         obj.方法名=function(){
 	   ...this.属性...
         }
      补: new和()都可省略，但不可同时省略
          new Object()
          Object()
          new Object
          Object
   2. 反复创建多个相同结构的对象:
     2步:
     1. 定义构造函数:
       function 构造函数名(属性参数,...){
	 //this->当前正在创建的空对象
         this.属性名=属性参数;
         this.方法名=function(){
	   ...this.属性...
         }
       }
       为什么:代码重用
       缺: 浪费了内存
     2. 用new关键词调用构造函数:
       var obj=new 构造函数名(属性值,...)
       new: 4件事
       1.创建一个空对象
       2.设置新对象的__proto__继承构造函数的原型对象。
       3.用当前新对象调用构造函数，向对象中添加属性和方法。
       4.将新对象地址，返回给变量保存。
  解决: 继承:
  面向对象三大特点: 封装 继承 多态
  继承: 父对象的成员，子对象不必重新创建，就可直接使用。
  js中的继承都是用过原型对象实现的
  原型和原型链： 
   原型:保存一类对象，共有成员的父级对象
   为什么: 为了实现继承,
       优: 代码重用和节约内存
   何时使用:只要一类对象共有的成员，都必须集中定义在原型对象中一次即可。
   如何使用:
     创建: 在定义构造函数时，js会自动创建该类型的原型对象
     向原型对象中添加共有成员:
       构造函数.prototype.成员名=值

   内置对象的原型对象: 
     解决浏览器的兼容性问题:
     如果需要的API，在指定类型的原型对象中不存在，说明不支持
       就要在该类型的原型对象中添加所需的共有成员。
       其中，在API内部，用this获得当前正再调用API的点前的对象

  原型链: 由各级父对象，逐级继承形成的链是结构。
  控制着对象成员(属性和方法)的使用顺序:
    优先使用对象本地的成员――自有属性
    如果本地没有，才延原型链向上查找各级父对象。直到找到为止。――共有属性
    如果整个原型链上没有，才返回undefined
  
  判断成员是自有属性，共有属性:
    1. 判断自有属性：
    var bool=obj.hasOwnProperty("属性名")
     判断"属性名"是否是obj的自有属性
         保存在obj对象本地。
     是自有属性，返回true，否则返回false
    2. 判断共有属性:
    问题:不是自有属性:
           1. 可能在原型链上
           2. 也可能根本没有
    解决:不是自有，且可以访问到
       !obj.hasOwnProperty("属性名")
       &&obj.属性名!=undefined

  如何修改自有属性和共有属性:
   自有属性，只能用所在的对象去修改
   共有属性，必须通过原型对象去修改
   如果强行使用某个子对象，修改共有属性
     后果: 仅在当前子对象添加同名自有属性
       导致:当前子对象无法再使用共有属性
  删除属性: delete 对象.属性 

  亲子鉴定：
   1.用原型对象检查
    var bool=father.isPrototypeOf(child)
    判断child是否继承自father
        father是否在child的原型链上
    如果father在child的原型链上，返回true
                            否则返回false
   2.用构造函数检查
    var bool=child instanceof 构造函数
     判断child是否是构造函数创建出来的子对象。
    补:instance实例:用一个构造函数创建出的一个子对象，就称为子对象是构造函数的实例。
      var obj=new 构造函数();
          实例化一个"构造函数"类型的对象
      var obj=new Array();
      var dt=new Date();
  多态: 同一个函数，在不同情况下，表现出不同的状态。
    重写(override):如果子对象，觉得父对象的成员不好用，就可在子对象本地，重新定义同名成员，来覆盖父对象的成员
    
  call: 强行借用一个本来无法调用到的函数
    目标函数.call(obj)
    执行时: 相当于obj.目标函数

*************************************************
                                第十三天 
闭包: 
 重用局部变量，并保护变量不被污染的机制
何时使用: 
 只要希望重用变量，又不被污染时
如何使用:3步:
 1. 用外层函数包裹受保护的变量和操作变量的内层函数
 2. 外层函数将内层函数返回到外部
 3. 调用外部函数，获得内层函数的对象
闭包如何形成: 
  外层函数的函数作用域对象没释放
鄙视:
 1. 先找受保护的变量，确定在外层函数调用后，变量最终的值
 2. 确定外层函数向外部返回了几个内层函数对象。所有内层函数对象，公用同一个变量。

缺: 比一般函数占用更多内存空间
    ――易造成内存泄漏

正课:
1.*****面向对象:
 对象: 程序中描述现实中一个具体事物的属性和功能的程序结构:
    事物的属性，就会成为对象的属性
      属性: 对象中保存一个属性值的变量
    事物的功能，就会成为对象的方法
      方法: 对象中定义的一个函数
    对象中的属性和方法统称为对象的成员
 对象又是，同时存储多个值的一块存储空间
 面向对象: 程序中都是先用对象来描述现实中一个具体事物的属性和功能。再按需调用对象的功能，操作属性。
 为什么: 为了更符合人的想法
 如何使用: 2步:
   1.创建对象:――封装 3种
     1. 对象直接量: (创建单独的对象)
     	var obj={
	    属性名:属性值,
            ...:...,
            方法名:function(){...},
            ...:...,
        }
        强调:
         1.js底层，一切对象都是hash数组。每个属性和方法其实都是hash数组中的元素。
         2.对象内的方法中访问对象自己的属性: 
         this.属性名
       其中: this默认指当前所在对象

     2. 用new: (创建单独的对象) 2步:
        1. 先创建空对象: 
	  var obj=new Object();
          new和()都可省略，但不能同时省略
        2. 再向空对象中添加属性和方法
          obj.新属性=值;
          obj.新方法=function(){...};
        强调: js中对象随时可添加新属性和方法。――底层就是hash数组
    3. 反复创建多个相同结构（同一类型）的对象:
	2步: 
       1. 定义构造函数: 
         构造函数: constructor
	  专门描述一类对象统一结构的函数
         function 类型名(属性参数){
	   this.属性名=属性参数;
           this.方法名=function(){...}
         }
       2. 用new调用构造函数，传入属性值:
         var obj=new 类型名(属性值,...);
     原理: new 4件事儿:
       1. 创建一个空对象
       2. ?
       3. 用空对象调用构造函数
         将构造函数中的this，替换为空对象
         构造函数会向空对象中添加新的属性和方法
       4. 返回新对象的地址保存在变量中

   this: 1. 对象的方法内，表示当前对象
      2. 构造函数中，表示正在创建的新对象

   2.调用对象的方法，操作对象的属性:
      对象.属性名: 用法和普通变量完全一样
      何时: 只有属性名固定不变时
      对象["属性名"]
      何时: 如果属性名是从变量中获得，或需要动态生成时。
      如果访问到不存在的属性，不会报错，返回undefined。
      对象.方法名();同普通的函数完全一样 
创建对象:
  1.创建一个单独的对象: 2种
    1.对象直接量:
      var obj={
	属性名:值,
        方法名:function(){
	  this.属性名
        }
      }
    2.用new:2步
      var obj=new Object();
      obj.新属性名=值;
      obj.新方法名=function(){
	this.属性名
      }

  js中对象本质: 一切对象底层都是hash数组
    相同: 
      每个属性都相当于hash数组中每个元素
        属性名就是字符串类型的key
        属性值就是元素值
      如果访问不存在的属性，不报错，返回undefined
      如果给不存在的属性赋值，会自动添加
      都可用for in循环遍历
    不同: 
      hash数组是Array类型
      对象是Object类型

  2.反复创建多个同一类型的相同结构的对象
    2步:
    1. 创建构造函数:
      function 类型名(属性参数){
	this.属性名=属性参数;
        this.方法名=function(){
	  this.属性名
        }
      }
      优: 代码重用
      缺: 无法节约内存
        解决: 继承
    2. 用new调用构造函数-实例(instance)化       var obj=new 类型名(属性值);

    new: 4件事
    1. 创建一个新的空对象
    2. 设置新对象的__proto__属性继承构造函数的原型对象。
    3. 用新对象调用构造函数
      将构造函数中的this，临时替换为新对象。
    4. 返回新对象的地址给变量

正课:
面向对象三大特点: 封装，继承，多态
封装: 将一个事物的属性和功能集中定义在一个对象中。
继承: 父对象的成员，子对象无需创建，即可直接使用。
多态: 同一个方法，在不同情况下，表现出不同的状态。

继承: 
为什么: 即能够代码重用，又节约内存
何时: 只要多个子对象中包含相同的成员，就可将相同的成员保存到父对象中一次，所有子对象，共同使用。
如何使用: 
  原型对象(prototype):
    集中保存所有子对象共有成员的父级对象
  原型对象不用创建，每个构造函数都自带一个原型对象。
  如何获得: 
    1. 构造函数.prototype
    2. 子对象.__proto__
       问题: __proto__是内部属性
       解决: Object.getPrototypeOf(obj)
         获得obj对象的父级原型对象
  如何向原型对象中添加共有成员: 
   构造函数.prototype.新成员=xxxx

操作属性:
  1. 修改自有属性，就必须用子对象
     lilei.age++;
  2. 修改共有属性，就必须用原型对象
     正确:
    Student.prototype.className="初二2班"

     lilei.className="初二2班" 
     错误:在lilei本地添加自有属性className,从此lilei无法再使用共有className属性。

  3. 删除属性:
    delete 对象.属性名
      只能删除当前对象自有的成员
      如果试图删除共有成员，不报错也无法删除。

判断自有、共有属性: 
  自有属性: 直接保存在当前对象本地的属性
    obj.hasOwnProperty("属性名")
    判断obj是否包含自有属性"属性名"
    true――是自有属性
    false――不是自有属性
  共有属性: 保存在原型对象中，多个子对象共享的属性
    !obj.hasOwnProperty("属性名")
    &&obj.属性名!==undefined
  
内置对象的API浏览器兼容性:
  对象.方法(): "方法"保存在对象的构造函数的prototype中。
  比如: Array.prototype : 包含了所有数组类型可用的API
      String.prototype : 包含了所有字符串类型可用的API

原型链(prototype chain):
  由各级对象的__proto__属性，逐级继承，形成的链式结构
  Object.prototype是所有对象的顶级父对象
  Function.prototype是所有函数对象的父对象。
  原型链控制着对象的成员的使用顺序:
    优先使用自有属性
    自己没有，才延原型链向父对象查找
    除非整个原型链上没有，才说明不可用

  vs 作用域链: 控制着变量的使用顺序
    优先使用函数作用域中的局部变量
    如果局部没有，延作用域链向全局找
    除非整个作用域链都没有，才说明不可用

判断继承关系: 
  1. 根据原型对象判断: 
    father.isPrototypeOf(child)
    判断father是否是child的父级对象
    判断child是否继承自father
    强调: 不仅检查直接父对象，而且检查整个原型链。
  2. 根据构造函数判断:
    child instanceof 构造函数
    判断child是否是构造函数创建出的实例
    强调: 不仅检查直接父级，而且检查整个原型链。

鄙视题: 判断一个对象是不是数组类型，有几种办法
  typeof(变量)无法区分普通对象和数组
 1.根据原型对象判断: 
   Array.prototype.isPrototypeOf(xxx)
 2.根据构造函数判断:
   xxx instancof Array
 3.根据对象的class属性判断:
   class: 每个对象的内部属性
         记录创建对象时使用的类型名
         一旦创建，无法修改。
   只有一个办法获得对象的class
    调用最原始的Object.prototype.toString方法
    [object Object]
     对象   class
   问题: 数组类型等内置类型，纷纷重写了toString方法，直接调用数组对象的方法，不再返回class属性值。
   解决: call 
    call强行借用一个函数，并临时替换函数中的this为指定对象。
    何时使用:强行借用一个本无法调用到的函数时。
    如何借用: 
 Object.prototype.toString.call(obj1)
 ==="[object Array]"

多态: 
  重写(override):子对象觉得父对象继承来的成员不好用，可以在本地定义同名成员，覆盖父对象成员。
  重写体现了子对象与父对象之间的差异
                           			
*************************************************
                                第十四天 
1. *****ES5
对象的属性:
  数据属性: 
    四大特性:
    value:
    writable:
    enumerable:
    configurable:
 传统方式设置的属性，特性的默认值都是true
  设置： 
   Object.defineProperty(obj,"属性名",{
      特性:值
   })
   如果obj中没有指定的属性名，则自动添加同名属性。但是，特性默认都是false！
    建议: 用defineProperty添加新属性时，尽量显式定义四大特性
   问题: defineProperty依次只能设置1个属性的四大特性。
    解决: Object.defineProperties(obj,{
             属性:{四大特性},
              ...:...
          })

  访问器属性: 不直接保存数据，为其他数据属性提供验证和保护的特殊属性
    四大特性: 
      get:function(){return xxx}
      set:function(val){
        验证val
	   xxx=val
      }
      enumerable:
      configurable:
    何时使用: 只要用自定义的规则保护属性时，都要用访问器属性
    如何使用: 2步:
     1. 定义数据属性，实际存储属性值
        问题: 使用者可直接操作数据属性，而绕过访问器属性的保护。
        解决: 闭包！
     2. 定义访问器属性，保护数据属性
       只能用defineProperty()
   Object.defineProperty(obj,"属性名",{
	get:function(){return xxx},
        set:function(val){xxx=val},
        enumerable:
        configurable:
   })
     get/set方法都不用手动调用：
     只要用访问器属性取值时，自动调get()
     只要用访问器属性赋值时，自动调set() 
       set中的参数val，会自动获得要赋的值
  构造函数中的访问器属性: 
  鄙视: 实现一个类型，同时包含public公有属性和private私有属性
    private私有属性: 仅在对象内部使用的属性，无法通过.访问到。
    public公有属性: 直接用对象.可访问到的属性。

防篡改: 禁止添加，删除，修改对象的属性
  1. 防扩展:
    每个对象中，都有一个默认的内部属性:
    extensible,默认为true，说明随时可扩展新属性。
    如果修改extensible属性为false，则禁止扩展新属性
    如何修改:
      Object.preventExtensions(obj)
      阻止对obj对象的一切扩展
  问题:只限制添加新属性，不限制删除旧属性
  2. 密封: 在防扩展的基础上，修改所有属性的configurable特性为false
    如何密封: Object.seal(obj);
       将obj对象密封
  3. 冻结: 在密封基础上，禁止修改所有属性的值。
    Object.freeze(obj);

Object.create():创建一个新对象，继承指定的父对象，同时为新对象扩展新属性
  何时使用: 只要基于一个现有父对象，创建一个子对象时。
  如何使用:
   var child=Object.create(father,{
      新属性:{四大特性},
       ...:...
   })

数组API: 
 1. 判断: 数组中的元素是否符合要求: 
   arr.every(...):判断arr中所有元素是否都符合要求。
   arr.some(...):判断arr中是否包含符合要求的元素。
   如何使用: 
    var bool=arr.every(
      function(val,idx,arr){
	return 判断条件
      }
    );
    every会用function去arr中每个元素执行检查。只有每个元素的执行结果都为true时，才返回true。只要任意一个不返回true，则every立刻返回false。
    说明: 
     val: 自动获得当前正在检查的元素值
     idx: 自动获得当前正在检查的元素位置
     arr: 自动获得当前正在检查的数组对象
  2.遍历: 对数组中的每个元素执行相同个操作
   arr.forEach(...):依次对arr中每个元素执行相同的操作，再保存回原数组。
     直接修改原数组
   arr.map(...): 依次取出arr中每个元素的值，执行相同操作，再保存到新数组中
     不直接修改原数组，返回新数组

1. *****ES5
对象的属性: 
 命名属性: 自定义的属性
   数据属性: 实际存储属性值得属性
     四大特性:
     value: 实际存储属性值
     writable: 控制是否只读
     enumerable: 控制能否被遍历(for in)到
       但是,用.依然可访问到
     configurable: 控制以上特性是否可修改，以及是否可以删除属性。

     如何查看四大特性:
     Object.getOwnPropertyDescriptor(
	obj,"属性名"
     )
     如何修改一个属性的四大特性:
     Object.defineProperty(
	obj,"属性名",{
	  特性:值,
           ...:...
        }
     )
     第三个参数中，只写需要修改的特性即可

     如果defineProperty修改的属性不存在，会自动创建。
     但是，defineProperty自动创建的属性，四大特性，默认都为false！
     而普通方式添加的属性,四大特性都为true。

     defineProperty问题：一次只能修改一个属性。
　　 解决: Object.defineProperties(
	      obj,{
    	        属性名:{
                   特性名:值,
                   ...:...,
                },
                ...
              }
           )
   问题: 数据属性对属性的保护比较简单
   解决: 用访问器属性自定义保护逻辑

   访问器属性: 不直接保存属性值，而是为其它数据属性提供保护的特殊属性
    四大特性: 
     get:function(){
	return 受保护的属性的值
     },
     set:function(val){
	//验证通过
	受保护的属性=val
     }
     enumerable:
     configurable:
    何时: 对一个属性自定义保护逻辑时
    如何:
     创建: Object.defineProperty(
	    obj,"属性名",{
             get:function(){return 属性},
             set:function(val){
 	       //先判断value
               属性=val
             }
            }
           )
     强调: 不要用同对象的另一个属性保存实际数据。因为极容易被篡改。
       解决: 使用闭包封装一个受保护的局部变量。

     何时调用:
       试图获取访问器属性保护的值，自动调用get方法
       试图为访问器属性保护的属性赋值时，自动调用set方法，会传入等号右侧的新值给val参数。

鄙视题: 在js中定义一个类型，包含公有属性(public)和私有属性(private)
   public: 在对象外，可用.访问到的属性
   private: 仅在对象内是使用的属性
     js中私有属性其实就是受闭包保护的一个局部变量。
   

 内部属性: 自动添加的，不允许外部随便访问的属性
   比如: __proto__    class

***防篡改: 
 防止对已经创建好的对象的属性进行增减。
 三个级别:
  1. 防扩展: 禁止向对象中添加新属性
    每个对象都有一个内部属性extensible,默认为true
     控制能否向对象中添加新属性
     设置对象防扩展: 
      Object.preventExtensions(obj)
      设置obj的内部属性extensiable为false
       使obj对象无法再扩展新属性
    问题: 不防删除
  2. 密封: 即防扩展，又设置所有属性的configurable为false！所有属性禁止删除
     Object.seal(obj);
     密封后，属性值，可改
  3. 冻结: 所有属性禁止增减，属性值禁止修改。
    何时使用: 专门定义一个对象，集中保存程序中使用的所有常量属性。
      为了保证对象内的常量属性不被修改，都要将整个对象密封起来:
       Object.freeze(obj);

Object.create(): 
 1.基于一个现有父对象，创建一个新子对象，
 2.继承父对象
 3.同时扩展子对象的自有新属性

 何时使用: 只要基于一个现有父对象，创建子对象时
 如何使用: 
  var child=Object.create(father,{
    同defineProperties中第2个参数
  })
  如果不扩展新属性，可省略第二个参数

*************************************************
                                第十五天 

回顾:
1. 访问器，public，private
2. 继承
  代码重用: 函数,对象,构造函数,继承
               重构        抽象
  如何继承:4种:   
   1. 修改两个现有对象间的继承关系:
      Object.setPrototypeOf(child,father)
   2. 基于现有父对象，创建子对象，并扩展新属性:
var child=Object.create(father,{新属性});
   3. 批量修改多个子对象的父对象:
     修改构造函数的prototype为新对象
     时机: 在创建第一个子对象之前
   4. 两种类型间的继承:
     问题: 多个子类型之间，包含相同的属性定义和方法。
     解决: 3步:
       1. 抽象父类型: 
          将相同的属性集中定义在父类型构造函数中。
          将相同的方法集中定义在父类型原型对象中
       2. 在子类型构造函数中借用父类型构
造
     父类型构造函数.apply(this,arguments)
       3. 设置子类型原型对象继承父类型原型对象。
     Object.setPrototypeOf(
	子类型原型对象,父类型原型对象
     )
正课:
1.*****ES5
  数组API
  *****bind
  严格模式

数组API: 
  indexOf/lastIndexOf:查找指定元素的位置
  Array.isArray(obj);

  判断数组中所有元素，是否符合要求:
  every:判断每个元素是否*都*满足要求
   arr.every(function(val,idx,arr){
      //回调函数用于检测每个元素:
      //val: 自动获得当前元素值
      //idx: 自动获得当前元素的位置 
      //arr: 自动获得当前正在遍历的数组
      return 判断结果;
   })
  some:判断是否*包含*满足要求的元素
   arr.some(function(val,idx,arr){
      ...
   })
正课:
1. *****ES5:
 数组API:
 *****bind:
 严格模式:

数组API:
 判断:
  arr.every(function(val,idx,arr){
    return 判断条件
  });
  arr.some(function(val,idx,arr){
    return 判断条件
  })
 遍历:
  forEach:对原数组中每个元素执行相同的操作.
  arr.forEach(function(val,idx,arr){
    //对arr[idx]的值做修改
  })
  map:基于原数组，将每个元素加工后，生成新数组。
  arr.map(function(val,idx,arr){
    //根据val，修改后，返回给新数组
    return 新值;
  })

 过滤和汇总:
  filter: 复制出原数组中符合要求的元素，组成新数组。
  var subArr=arr.filter(
    function(val,idx,arr){
       return 条件
    }
  );
 
  reduce: 将数组中每个元素的值汇总出一个结果。
  var r=arr.reduce(
    function(prev,val,idx,arr){
       //prev: 获得目前截止的汇总值
       return prev和val的汇总值
    },
    开始值
  );

bind: 基于现有函数，创建一个新函数，提前永久绑定函数中的this为指定对象。
  
(call vs apply) vs bind
call,apply: 强行借用一个函数，并临时替换函数中的this为指定对象。
  call,apply其实是执行一个函数
bind: 创建一个新函数，并永久绑定this和部分参数。
  bind不是执行函数，而是创建新函数

*************************************************
                                第十六天 
正课:
1. DOM:
  什么是DOM
  ***DOM Tree
  ***查找

原生js: ECMAScript5(核心语法)+
        DOM(操作网页内容的API 3天)+
        BOM(操作浏览器窗口的API 2天)

什么是DOM:专门操作网页内容的API
何时: 只要修改网页内容，都要用DOM
      查找,修改,添加,删除
鄙视:HTML XHTML XML DHTML
  HTML:超文本标记语言 
       专门编写网页内容的语言
  XHTML: 更严格的HTML语言标准
  DHTML: 所有实现网页动态效果的技术的统称
      DHTML: HTML+CSS+JS
  XML: 可扩展标记语言
      用于存储或在网络间传输结构化数据
   <student>
     <name>杨幂</name>
     <math>81</math>
     <chs>65</chs>
     <eng>89</eng>
   </student>
   JSON:JavaScript Object Notation
   '{"name":"杨幂","math":81,"chs":65}'

DOM: 核心DOM: 操作一切结构化文档
         即可操作HTML文档，也可操作XML
         优: 万能
         问题: 繁琐
     HTML DOM: 专门操作HTML网页的DOM标准
          对核心DOM的部分常用API的简化
          优: 简化
          缺: 不是万能
     实际开发中: 优先使用简化版HTML DOM
            如果无法实现，才用核心DOM补充
     XML DOM: 专门操作XML文档的DOM标准

***DOM Tree:
 当浏览器获取到HTML代码时，首先会在内存中创建document对象
   document对象: 指代正在加载的网页
                 包含网页中一切内容
 浏览器会依次读取html代码的每个元素和内容，每读取一个内容就创建一个节点对象(Node)
 内存中，html的所有内容都是以树形结构存储的。
    document对象是树根
    所有的内容节点都是document的子代节点
    document节点可以操作一切子节点。

节点对象:(Node)
  网页中一切内容都是节点对象
  三大属性: 
  node.nodeType: 节点类型
    只要判断节点的类型，就用nodeType
    值:
      根节点document: 9
      元素节点: 1
      属性节点: 2
      文本节点: 3
  node.nodeName: 节点名
    用于进一步区分元素的标签名
      根节点document: #document
      元素节点: 标签名 强调: 全大写
        比如: if(node.nodeName=="INPUT")
      属性节点: 属性名
      文本节点: #text
  node.nodeValue: 节点值
      根节点document: null 失效
      元素节点: null 失效
      属性节点: 属性值
      文本节点: 文本内容

节点树: 包含一切网页内容的完整树结构
节点间关系:
1. 父子关系:
   node.parentNode 父节点
   node.childNodes 所有直接子节点
   node.firstChild 第一个直接子节点
   node.lastChild 最后一个直接子节点
2. 兄弟:
   node.previousSibling 前一个兄弟
   node.nextSibling 后一个兄弟
强调: 文本节点也是节点对象
   以上6个关系都会受看不见的空文本的干扰

元素树:仅包含元素节点的树结构
  何时: 希望仅访问元素节点时
    优: 不会受到文本节点的干扰
1. 父子关系: 
  node.parentElement 父元素
  node.children 所有直接子元素
  node.firstElementChild 第一个直接子元素
  node.lastElementChild 最后一个直接子元素
2. 兄弟关系:
  node.previousElementSibling 前一个兄弟元素
  node.nextElementSibling 后一个兄弟元素
       
强调: 元素树的API是IE9+
      只有children没有兼容性问题
childNodes和children: 返回的是动态集合
  动态集合:live collection
    不实际存储每个节点的所有属性。
    只要访问动态集合，都会重新查找DOM树
    优: 首次查找快
    缺: 反复访问集合，会造成反复查找DOM树
   所以在遍历时，必须先缓存length，再遍历
for(var i=0,len=children.length;i<len;i++

不需要查找，可直接获取的！
document.documentElement -> html元素
    所有元素的父元素
document.body -> body元素
document.head -> head元素

遍历节点树: (手写)
  依次查找指定父节点下的所有子代节点
2步: 
1. 实现仅遍历直接子节点的方法
2. 再在遍历过程中，对每个直接子节点执行和父节点相同操作

深度优先遍历: 如果同时需要遍历兄弟节点和子节点时，总是优先选择子节点遍历。

arguments.callee: 自动获得当前正在执行的函数对象本身。
  专用于在递归时，在函数内，代替当前函数本身。
      
 正课:
1. 遍历API
2. ***查找:

1. 遍历API:
  NodeIterator: 按深度优先的顺序遍历指定父节点下的所有子代节点
   何时: 只要遍历所有子代节点
   如何: 2步:
    1.创建nodeIterator对象:
     var iterator=
	document.createNodeIterator(
	  parent,NodeFilter.SHOW_ALL,
                 	   .SHOW_ELEMENT
          null,false
        )
    2.反复调用iterator的nextNode方法:
       获得当前所在节点，并让iterator跳到下一个节点。
      nextNode方法: 先返回当前所在节点
                    再让iterator跳到下一个节点。
          如果没有下一个，返回null
  var node=null;
 while((node=iterator.nextNode())!=null){...}
  强调: 使用迭代器比自定义递归算法效率要高。
   另一个方法: iterator.previousNode();
       先返回上一个节点，再输出返回后所在的节点。
  问题: 只能严格按照深度优先顺序遍历
  需求: 如果向任意方向跳转
  TreeWalker: 基本用法和iterator完全一样
   差别:1. nextNode(),先跳到下一个节点，再返回跳转后的新节点。
        2. previousNode(),先跳会前一个节点，再返回跳转后的节点。
       3. 5个新的API:
         walker.parentNode();
         walker.firstChild();
         walker.lastChild();
         walker.previousNode();
         walker.nextNode();

***查找:
 今后，操作任何节点前，都要先找到要操作的节点。
 如何:
  1.按HTML查找:
    1. 按id查找一个元素
   var elem=document.getElementById("id")
       强调: 必须使用document调用
    2. 按标签名查找多个元素
   var elems=
    parent.getElementsByTagName("标签名")
       强调: 
         1. 可用任何父元素调用
         2. 不仅查找直接子节点，而是查找所有子代节点
         3. 返回值是live collection
    3. 按name属性查找多个元素
   var elems=
    	parent.getElementsByName("name");
    4. 按class属性查找多个元素
   var elems=
   parent.getElementsByClassName("class")

课堂练习: 事件处理函数中的this:
 事件处理函数中，this指事件绑定的元素对象
 何时: 事件处理函数中，需要鉴别或使用当前元素对象时

  2. 按选择器查找:
   1. 只查找一个符合选择器条件的元素:
var elem=parent.querySelector("selector")
   2. 查找多个符合选择器条件的元素：
var elems=
     parent.querySelectorAll("selector");
    返回值: no-live collection
            非动态集合
      集合中实际存储了每个节点的具体数据
      反复访问集合，不会导致重新查找DOM树
      所以，遍历时，不必先缓存length

  鄙视: getXXXByXXX  vs querySelector
         动态集合        静态集合
       如果只有一次查找  一次查找效率低
       效率高的！
        反复查找繁琐     简单
   选择: 如果只要一次查找就可得到元素时
	首选getxxx
         如果需要经过多级查找，才能得到元素时，首选querySelector

   querySelector是jquery的核心
     
**********************************************
			第十七天
正课:
1.添加,删除元素
2.***HTML DOM 常用对象:
  Image Select   Table   Form
         Option    ...

1. 添加，删除元素:
 添加元素:3步:
   1. 创建空元素对象:
   var a=document.createElement("标签名")
   等效于: <a></a>
   2. 添加关键属性: 
    a.href="http://tmooc.cn";
    a.innerHTML="go to tmooc";
   等效于:
<a href="http://tmooc.cn">go to tmooc</a>
   3. 将新元素添加到指定父元素下:
     追加: parent.appendChild(a);
       将a追加到parent的子元素末尾
     插入: parent.insertBefore(a,旧元素)
       将a插入到parent下的"旧元素"之前
     替换: parent.replaceChild(a,旧元素);
       删除旧元素，将a放在旧元素的位置。

优化: 尽量少的操作DOM树
浏览器的加载过程:
HTML->DOM树
        ↓
       render Tree->*layout*->paint
        ↑
CSS->cssRules
  每操作一次DOM树，都会导致重新layout
  频繁操作DOM树，会频繁layout，会效率低
解决: 
  1. 如果同时挂父元素和子元素：
    先在内存中将子元素都挂到父元素上
    再将父元素整体挂到页面上一次即可
  2. 如果父元素已经在DOM树中，要挂多个平级子元素:
    文档片段: 内存中，临时存储多个平级子元素的虚拟临时父节点
    如何: 3步:
     1.创建文档片段:
   var frag=
      document.createDocumentFragment();
     2.将子元素添加到frag中
       frag.appendChild(child);
     3.将frag整体追加到父元素下:
       parent.appendChild(frag);
     frag只将子节点挂到父元素下，就释放了

 练习: 
  select元素都有onchange事件:
    当选中项发生改变时触发
    获得当前选中项的下标: 		select.selectedIndex
回顾:
1.添加元素:3步:
 1. 创建空元素:
   var a=document.createElement("a");
 2. 设置关键属性:
   a.href="http://tmooc.cn"
   a.innerHTML="go to tmooc"
 3. 将新元素添加到指定父元素下
   parent.appendChild(a)
   parent.insertBefore(a,oldElem)
   parent.replaceChild(a,oldElem)

优化: 尽量减少操作DOM树
解决: 
 1. 如果同时添加父元素和子元素:
   先在内存中将子元素添加到父元素
   再将父元素一次性添加到页面
 2. 如果父元素已经在页面上，要添加多个平级子元素:3步:
   1. 创建文档片段:
   2. 将子元素放入文档片段
   3. 将文档片段一次性添加到页面

删除节点: 
  parent.removeChild(child);
  child.parentNode.removeChild(child);

正课:
1.HTML DOM常用对象:
  Image对象：<img>
  var img=new Image();

  Select对象: 
   属性:
     selectedIndex: 获得当前选中项的下标
     options: 获得select下所有option元素
     value:
       如果选中项有value值，则返回value值
       如果选中项没有value值，返回选项的内容文本
   方法:
     add(opt): 将opt添加到select元素上
     remove(i): 移除i位置的选项
   事件:
     onchange: 当选中项发生改变时

  Option: 
   创建: var opt=new Option(text,value)
   属性: 
    index: 选项在select中的下标
    text: 代替innerHTML，访问option的内容

  Table对象:
   tHead: 添加 createTHead -> tHead
          删除 deleteTHead
     	tr: 添加: insertRow(i) -> tr
            在thead中下标为i位置插入一行
            原i位置的行被向后顺移
            如果省略i，默认末尾追加一样
            删除: deleteRow(i)
             删除tHead内i位置的行
             如果省略i，删除第1行
            获取: rows
           td: 添加: insertCell(i)
               删除: deleteCell(i)
               获取: cells
   tBodies: 
     tBody: 添加 createTBody -> tBody
   tFoot: 添加 createTFoot -> tFoot
          删除 deleteTFoot

  Table对象:
    tr: 添加: insertRow(i)
        删除: deleteRow(i)
          i相对于整个表中行下标
        获取: rows

  TableRow:(tr) rowIndex 表示当前行在整个表格中的下标位置。
    table.deleteRow(tr.rowIndex)

  练习:
  在事件绑定时，尽量避免形成闭包: 
    在事件处理函数中，不要随便使用外层函数的变量（尤其是引用DOM对象的变量）

  BOM三种对话框:
   alert("警告")
   var input=prompt("输入")
   var bool=confirm("确认框")
      确定->true  取消->false

  Form对象:
   获取form对象: 
     var form=document.forms[i/id/name]
   属性: 
     elements: 仅包含所有表单元素的集合
     length: 就是elements的length
   方法:
     submit();//手动提交
     reset();
   获取form中的元素?
     form.elements[i/id/name]
     form.id/name

  表单元素: 
    elem.focus(); 让elem获得焦点
    elem.blur(); 让elem失去焦点

*************************************************
			第十八天
正课:
1. BOM:Browser Object Model
 DHTML模型
 打开关闭窗口
 *****定时器

DHTML模型:
 window: 2个角色:
    1. 代替Global充当全局作用域
    2. 封装操作浏览器窗口的API――BOM
 history: 封装当前窗口打开后，成功访问过的url历史记录的栈――前进，后退，刷新
 navigator: 封装浏览器软件的配置信息
 document: 封装所有网页内容
 location: 封装当前窗口正在打开的url对象
 screen: 封装了当前显示器的信息
 event: 在事件发生时，保存事件相关信息

window对象:
打开和关闭窗口:
  window.open(...) 
  window.close() 关闭当前窗口
 打开新链接的方式：4种:
  1. 在当前窗口打开，可后退
    html: <a href="url"></a>
    js:open("url","_self")
  2. 在当前窗口打开，不可后退
    js:location.replace("新url")
       用新url替换history中当前url
  3. 在新窗口打开，可重复打开
    html: <a href="url" target="_blank"
    js: open("url","_blank")
  4. 在新窗口打开，只能打开一个
    html: <a href="url" target="name"
    js: open("url","name")

  window.name:标示当前窗口在内存中的唯一名称。 
   打开链接时指定name属性: 
     <a href="url" target="name"
   规定: 同一name的窗口只能打开一个
         后打开的会刷新先打开
     预定义值: _self 当前窗口自己
               _blank 没名称的窗口

窗口位置和大小: 
 窗口大小: 
   完整大小: outerWidth/outerHeight
   文档显示区大小: innerWidth/innerHeight
 调整窗口大小: 2种情况:
   1. 在打开窗口时，就调整大小
     2步:
      1. 定义配置字符串:
        var config=
          "top=?,left=?,width=?,height=?"
         强调: width和height仅是文档显示区的大小。
           top和left却是整个窗口左上角的坐标。
      2. 在打开窗口时，将config作为第三个参数。
   特殊: 多数浏览器不允许修改当前窗口大小。只能修改新弹出的另一个小窗口的大小。
   2. 调整新窗口大小:
   pop.resizeTo(width,height)
   让窗口变到指定大小
   pop.resizeBy(width的增量,height的增量)
 
 窗口位置: 
   window.screenLeft/screenTop
   修改窗口的位置: 
   pop.moveTo(left,top)
   pop.moveBy(left增量,top增量)

 练习: 
  获得屏幕大小：
    完整大小: screen.width/height
    可用大小: 	screen.availWidth/availHeight

*********************************************
			第十九天

正课:
1.BOM常用对象:
  history location navigator
***event

history: 保存当前窗口打开后，成功访问过的url的历史记录栈
  强调: history几乎没有开放任何结构
  如何:
    前进：
      前进一次: history.go(1)
      前进n次: history.go(n)
    后退：
      后退一次: history.go(-1)
      后退n次: history.go(-n)
    刷新: history.go(0)

location: 封装当前窗口正在打开的url的对象
  属性: 
    href: 完整url
      location.href="新url" 在当前窗口打开新url
	其实location="新url"
    protocol: 协议
    host: 主机名+端口号
    hostname: 主机名
    port: 端口号
    pathname: 相对路径
    hash: 跳转到的锚点名: #xxx
    search: ?及其之后的查询字符串
  方法: 
    location.assign("新url")
      等效: location.href="新url"
    location.reload(true/false);
      重新加载当前页面:
      参数: 是否强制从服务器硬盘获取网页
	默认是false:只要有缓存就不去硬盘拿
        改为true，无论是否有缓存，都从服务器硬盘获取最新网页
    location.replace("新url");
      替换history中当前url，实现禁止后退

navigator: 封装浏览器配置信息的对象
  cookieEnabled: 判断网页是否启用了cookie
   cookie:客户端持久存储用户私密信息的文件.
  plugins: 封装所有插件信息的集合
    每个插件的name属性，可辨别插件名

  userAgent: 保存浏览器名称和版本号的字符串

正课:
1.***event
  事件: 用户和web页面的交互
  event对象: 事件发生时，自动创建，封装事件信息的对象
  事件处理函数: 事件发生时自动调用执行的函数。
    事件处理函数的本质: 其实就是节点的一种特殊属性。只不过赋值为function
    最全的事件处理函数列表:
    https://developer.mozilla.org/en-US/docs/Web/Events
  
绑定事件处理函数: 
 为元素的指定的事件名赋值一个函数对象: 
 3种:
 1. 在html中定义事件处理函数:
   <button on事件名="js语句"
           onclick="mySubmit()"
 2. 在js中动态绑定事件处理函数:
   2种:
     1.直接给元素的事件处理函数属性赋值
      btn.on事件名=function(){
	//this->btn
      }
      问题: 1. 一个事件处理函数只能绑定一个函数对象。
          2. 无法改变事件触发的顺序
     2.使用addEventListener函数
      btn.addEventListener(
	"事件名",函数对象,true/false
      );
      第三个参数: 是否在捕获阶段提前触发
       默认false，都在冒泡阶段触发
       改为true，会在捕获阶段提前触发
      解除绑定: 
      btn.removeEventListener(
        "事件名",函数对象
      )
      强调: 要想解绑:
        1.绑定时，就用有名的函数绑定
        2.解绑时，要和绑定时使用相同的函数名

***DOM事件周期: 3个阶段
 1.捕获: 由外向内,依次记录各级父元素绑定的事件处理函数。
   强调: 捕获只到目标元素结束
 2.目标触发: 先触发实际点击的元素的事件处理函数。
   目标元素: 实际点中的元素
 3.冒泡: 按捕获的顺序，由内向外，冒泡执行记录的每个事件处理函数

获得事件对象e:
  DOM标准: 自动创建的事件对象e，会作为事件处理函数的第一个参数传入
取消冒泡:
  e.stopPropagation();
利用冒泡:(jquery中的delegate)
优化: 尽量少的添加事件监听对象
  解决: 如果多个子元素绑定了相同的事件处理函数，则仅在父元素绑定一次即可！
  核心: 如何获得目标元素: e.target
    this vs e.target
     this会随冒泡而改变,只会表示当前触发事件的元素
     e.target不随冒泡改变，始终表示最初触发事件的目标元素
  强调: 屏蔽不触发事件的其它元素的干扰。

取消事件(阻止默认行为):
  e.preventDefault();
  练习: form事件: onsubmit
          当最终提交前自动触发
事件坐标: 
  相对于屏幕左上角: screenX/screenY
  相对于文档显示区左上角: clientX/clientY
                                x/y
  相对于所在元素左上角的坐标:offsetX/
                             offsetY


***********************************************
			第二十天
正课：
1. 页面滚动：
   事件: window.onscroll
	当页面发生滚动时出发
   获得页面滚动过的顶部的距离
   

   document.documentElement.scrollTop
	说明：scrollTop指body的顶部到文档显示区顶部的距离
	方法：
	scrollTo(left,top)
	scrollBy(left的增量,top的增量）
   获得任意元素距body顶部的距离：
	offsetTop:获得当前元素距相对定位的父元素顶部的距离(包括margin)
	offsetParent:获得当前元素相对元素的父元素的对象
	
********************************************
			第二十一天
正课:
1.cookie:
 what: 在客户端本地，持久存储用户私密数据的文件.
 why: 内存中一切数据都是临时的
 when: 只要在客户端本地，持久存储用户的私密数据
 how: 
  写入cookie：
    document.cookie=
       "变量名=值;expires="
       	+date.toGMTString()
  读取cookie的数据: 
    var str=document.cookie;
    

  练习: 
   Chrome不允许本地的网页创建cookie
   Firefox允许

2.严格模式:
  比普通的js运行模式，要求更严格的执行环境。
  何时启用: 
    旧项目: 逐个功能启用严格模式
    新项目: 开始就启用严格模式
  如何启用:
    "use strict";
    2种地方:
    1. <script>标签的开头
       整个script中的所有代码启用严格模式
    2. function的开头
       仅当前函数内的代码启用严格模式
  严格模式:
   1. 静默失败升级为错误
   2. 不允许对未声明的变量赋值！
   3. arguments少用
       arguments.callee ->指代当前正在调用的函数本身――专用于递归调用
   4. 增加了eval作用域:
      eval中声明的变量，eval外不能使用

*********************************************
			第二十三天
1. 复习：DOM
DOM把HTML文档看做对象（节点）树，操作对象（节点），操作HTML文档。
(1)查找节点：document.getElementById()|getElementsByTagName()|getElementsByClassName()|getElementsByName()|querySelectorAll()|querySelector()
node.getElementsByClassName()|getElementsByTagName()|getElementsByName()
(2)操作节点的属性：node.getAttribute(名称)|setAttribute(名称,值)
(3)操作节点的内容：node.innerHTML|innerText|textContent
(4)操作节点的值：input.value
(5)操作节点的样式：node.style.样式名=值；document.getComputedStyle()|node.class 
(6)遍历节点：node.parentNode|childNodes|childen|nextChild|lastChild|firstChild| previousSibling|nextSibling
(7)添加节点：parent.appendChild(child)|document.createElement()
(8)删除节点：parent.removeChild()
(9)替换节点：parent.replace(new,old)
(10)克隆节点：parent.cloneNode()



 
